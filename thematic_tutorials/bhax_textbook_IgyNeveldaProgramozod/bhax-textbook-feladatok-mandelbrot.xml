<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
            <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngt.c++">
                <filename>bhax/attention_raising/CUDA/mandelpngt.c++</filename>
            </link> nevű állománya.            
        </para>
        <para>
            Az ebben a fejezetben szereplő programok, mind szervesen kötődnek egymáshoz. Ha sikerül egy képet megcsinálni 
            akkor az összes programot át tudjuk rá ültetni, tehát egy másik programváltozattal tudunk benne majd nagyítani, 
            vagy úgy is át tudjuk majd írni, hogy a GPU-t használja, ezáltal nagyon meggyorsítva a számítási folyamatokat.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Mandelbrot/5.1/mandelpngt.cpp">../Forraskodok/Mandelbrot/5.1/mandelpngt.cpp</link>   
        </para>
        <programlisting language="c++">
<![CDATA[// mandelpngt.c++
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
//  Mandelbrot png
//  Programozó Páternoszter/PARP
//   https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux
//
//  https://youtu.be/gvaqijHlRUs
//
#include <iostream>
#include "png++/png.hpp"
#include <sys/times.h>

#define MERET 600
#define ITER_HAT 32000]]>
        </programlisting>
        <para>
            A program elején, mint mindig, megadjuk a header fájlokat. Ez esetben ami ismeretlen lehet az a png++/png.hpp 
            és a sys/times.h fejlécek. Az elsőre azért van szükségünk, hogy létre tudjuk hozni a képet, hogy viziálisan  
            is láthassuk a Mandelbrot halmaz eredményét, ami kép. A második header fájl pedig az idővel kapcsolatos számításokat, 
            az idővel összefüggő függvények meghívását biztosítja számunkra. Idlletve efiníciő megadaások is szerepelnek, 
            melyek majd könnyítik a dolgunkat a program írása alatt.
        </para>
        
        <programlisting language="c++">
<![CDATA[void
mandel (int kepadat[MERET][MERET]) {

    // Mérünk időt (PP 64)
    clock_t delta = clock ();
    // Mérünk időt (PP 66)
    struct tms tmsbuf1, tmsbuf2;
    times (&tmsbuf1);

    // számítás adatai
    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

    // a számítás
    float dx = (b - a) / szelesseg;
    float dy = (d - c) / magassag;
    float reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;
    // Végigzongorázzuk a szélesség x magasság rácsot:
    for (int j = 0; j < magassag; ++j)
        {
        //sor = j;
        for (int k = 0; k < szelesseg; ++k)
            {
            // c = (reC, imC) a rács csomópontjainak
            // megfelelő komplex szám
            reC = a + k * dx;
            imC = d - j * dy;
            // z_0 = 0 = (reZ, imZ)
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            // z_{n+1} = z_n * z_n + c iterációk
            // számítása, amíg |z_n| < 2 vagy még
            // nem értük el a 255 iterációt, ha
            // viszont elértük, akkor úgy vesszük,
            // hogy a kiinduláci c komplex számra
            // az iteráció konvergens, azaz a c a
            // Mandelbrot halmaz eleme
            while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
                {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ * reZ - imZ * imZ + reC;
                ujimZ = 2 * reZ * imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                ++iteracio;
                }

            kepadat[j][k] = iteracio;
            }   
        }

        times (&tmsbuf2);
        std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
        + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

        delta = clock () - delta;
        std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

        }]]>
        </programlisting>
        <para>
            A <function>mandel</function> függvény az ami majd kiszámolja nekünk a Mandelbrot halmazt. Egy időszámítás jön, 
            ami segítségével majd a program lefutás után kiírja azt az időt amit igénybe vett a számolás (az én
            gépen és egy i3-3227U-s processzor esetén ez körülbelül egy 15 másodpercbe telt). Ezek és a 
            változódeklarálások után jöhetnek a nagyobb számítások. Létrehozunk egy dx szélességű és dy magasságú 
            rácsot a két egymásbaágyazódó for ciklus segítségével, majd megvizsgáljuk, hogy a <varname>c</varname> komplex szám (mely megkapja a <varname>reC</varname> 
            és a <varname>imC</varname> értékek által meghatározott pontot, pixelt) benne van-e a Mandelbrot halmazban, 
            ha igen akkor azt a pontot beszinezi.
        </para>
        
        <programlisting language="c++">
<![CDATA[int
main (int argc, char *argv[])
{

    if (argc != 2)
    {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }

    int kepadat[MERET][MERET];

    mandel(kepadat);

    png::image < png::rgb_pixel > kep (MERET, MERET);

    for (int j = 0; j < MERET; ++j)
    {
        //sor = j;
        for (int k = 0; k < MERET; ++k)
        {
            kep.set_pixel (k, j,
            png::rgb_pixel (255 -
            (255 * kepadat[j][k]) / ITER_HAT,
            255 -
            (255 * kepadat[j][k]) / ITER_HAT,
            255 -
            (255 * kepadat[j][k]) / ITER_HAT));
        }
    }

    kep.write (argv[1]);
    std::cout << argv[1] << " mentve" << std::endl;
}]]>
        </programlisting>
        <para>
            A főprogram elején megvizsgáljuk, hogy a felhasználó jól hsználta-e a futtatási parancsot, tehát hogyha a parancs nem két 
            argumentumból áll, akkor kiírunk egy hibaüzenetet a kimenetre. A <varname>kepadat</varname> változóba bekérjük a méreteket,
            tehát a kép szélességét és a magasságát majd ezeket átadjuk a <function>mandel</function> függvénynek, ami kiszámolja nekünk 
            a mandelbrot halmazt, és ez alapján megalkotjuk a png kiterjesztésű képet. Miutána  program befejezte a számításokat és 
            sikeresen megcsinálta a képet, kiírja a kimenetre a "mentve" üzenetet a felhasználó számára, tudatva a sikert.
        </para>
        
        <para>
            Fordítás: <command>g++ mandelpngt.cpp -lpng -O3 -omandelpngt</command> 
        </para>
        <para>
            Futtatás: <command>./mandelpngt mt.png</command>
        </para>
        <para>
            Kép megnyitása terminálból: <command>eog mt.png</command>
        </para>
        <figure>
            <title>A kiadott kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mt.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A kiadott kép</phrase>
                </textobject>
            </mediaobject>
        </figure> 

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                       
            A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
            ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        <para>
            A feladatban tutora voltam Schachinger Zsolt-nak.
        </para>
        <para>
            Felvetődik egy kérdés: melyikaz a szám amelyiket önmagával megszorozva 9-et kapunk (természetesen ez a 3). 
            Ebből kiindulva a következő kérdés pedig az, hogy melyik az a szám amit ha megszorozunk önmagával -9-et kapunk? 
            Ez pedig már nem lehetséges a valós számhalmazon, így jönnek képbe a komplex számok, melyek úgymond a valós 
            számhalmaz továbbővítése. A komplex számok alapja az "i" szám, melynek értéke a sqrt(-1), ennek a segítségével 
            el lehet végezni a negatív számból való négyzetgyökvonást. Így már meg tudjuk válaszolni az előbb feltett kérdést, 
            az "i" szám segítségével már ki tudjuk hozni a -9-et (tehát 3i*3i).
        </para>
        <para>
            Ez a program és az előző közötti legnagyobb kölönbség az hogy a <varname>c</varname> amit vizsgálunk, hogy benne van-e
            a Mandelbrot halmazban, az előző programban egy változó, ebben pedig egy állandó. Így itt a c a rács minden 
            vizsgálandó pontját befutja.
        </para> 
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Mandelbrot/5.1/mandelbrotcomplex.cpp">../Forraskodok/Mandelbrot/5.1/mandelbrotcomplex.cpp</link>   
        </para>
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {        
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }]]></programlisting>
        <para>
            A program elején a header fájlok deklarálása után (iostream, a cin, cout miatt főleg; png++/png.hpp, 
            a kép létrehozása miatt; complex, a komplex iterációk és ahogy a címben is említve van a komplex osztályos megoldás miatt) jönnek a változók deklarálása, ezek a változók 
            (<varname>szelesseg</varname>, <varname>magassag</varname>, <varname>iteraciosHatar</varname>, <varname>a</varname>, 
            <varname>b</varname>, <varname>c</varname> és <varname>d</varname>) a futtaási parancsban is fontos szerepet 
            játszanak hiszen az első két argumentum után (ami a ./futtató fájl neve illetve egy png féjlnév, ami a mentett kép
            neve lesz) ahogy deklarálva vannak, úgynilyen sorrenbe vannak megadva szóközzel elválasztva egymástól. Miután a változók
            deklarálva lettek, megvizsgéljuk hogy a felhasználó jól futtat-e a programot, tehét hogyha a parans 9 argumentumból áll 
            akkor megadjuk a programban, hogy az egyes változók hányadik értéket kapják meg a parancsból, tehát hogy a program tudja
            hogy az egyes értékek mit jelentenek számára. Ha vizsont a parancs nem 9 argumentumból áll, akkor kiíratunk az outputra 
            egy üzenetet a felhasználónak, hogy tudja a helyes futtatási használatot, <command>return -1</command>-el pedig az 
            operációs rendszernek is jelezzük a hibát.
        </para>
    
        <programlisting language="c++">
<![CDATA[  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {
          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>  
        <para>
            A számítások részben deklaráljuk a <varname>reC</varname>, <varname>imC</varname>, <varname>reZ</varname> 
            és <varname>imZ</varname> (valós és imaginárius részű) változókat, melyekből már látszik is hogy a feladatban 
            sokszerepet fognak játszani a komplex számok. A c=(reC, imC) a haló rácspontjainak megfelelő aktualis pont
            Úgyanúgy mint az előző programban a két for ciklus segítségével megcsináljuk a rácsot, elindulunk az 
            origóban majd egy <varname>c</varname> pontra ugrunk a c<superscript>2</superscript>+c majd ez az egesz a 
            négyzeten +c és így tovább. Ha sikeres volt minden művelet, akkor kiíratunk a standard kimenetre egy "mentve" 
            üzenetet, melyből a felhasználó tudja is hogy a kép sikeresen el lett készítve, lehet megtekinteni. 
        </para>
        <para>
            Fordítás: <command>g++ mandelbrotcomplex.cpp -lpng -O3 -o mandelbrotcomplex</command> 
        </para>
        <para>
            Futtatás: <command>./mandelbrotcomplex mandelcomplex.png 1920 1080 1020 
                0.4127655418209589255340574709407519549131 
                0.4127655418245818053080142817634623497725 
                0.2135387051768746491386963270997512154281 
                0.2135387051804975289126531379224616102874</command>
        </para>
        <para>
            Kép megnyitása terminálból: <command>eog mandelcomplex.png</command>
        </para>
        <figure>
            <title>A program áltak megcsinált kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelcomplex.png" scale="20" />
                </imageobject>
                <textobject>
                    <phrase>A program áltak megcsinált kép</phrase>
                </textobject>
            </mediaobject>
        </figure>      
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para> 
        <para>
            A cikkben arról olvashatunk, hogy Pickover amikor felfedezte a biomorfokat, teljesen meg volt győződve 
            arról hogy felfedezte a természet törvényeit, tehát hogy hogyan néznek ki és alakulnak ki az élő orgazmusok.
            A cikkben látjuk azt is, hogy a különböző képeket különböző függvények segítségével hozunk létre, hasonlóan a Mandelbrot 
            halmazhoz, elindul a rácson és azon végzi el a képhez tartozó függvényt. A program a komplex számsíkon dolgozik, 
            tehát van "i" számunk, és a c egy állandó .Próbáljuk ki és nézzük meg hogy hogy is mülködik a program.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Mandelbrot/5.1/biomorfok.cpp">../Forraskodok/Mandelbrot/5.1/biomorfok.cpp</link>   
        </para>                        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }]]>
        </programlisting>
        <para>
            Header fájlként megadjuk a képkészítéshez a png++/png.hpp fejlécet, majd ami új az pedig a complex header fájl 
            ami természetesen a komplex számokkal való számolás miatt kell. Ezek után már kezdjük is a főprogramot, melyben 
            legelőször deklaráljuk a változókat, majd meghatározzuk a magasságot, szálességet és a rácsban való mozgáshoz 
            szükségez koordnátákat. Ez a kép kirajzoltatásához a <varname>c</varname> állandó értékében most nincs "i", ezért 
            a <varname>c</varname>-nek a valós részéhez (reC) adunk meg 0-tól különböző értéket, az imaginárius, képzett 
            részéhez (imC) pedig 0-t.
        </para>

        <programlisting language="c++">
<![CDATA[png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>   
        <para>
            A következő programrészben, az első pixelre állunk, majd elkezdjük a számításokat. A két egymásbaágyzó for 
            ciklussal rácsot teszünk a komplex számsíkra (ahol a <varname>j</varname>-vel a soron, a <varname>k</varname>-al 
            pedig az oszlopon megyünk végig). Az előző complex osztállyal megvalósított Mandelbrot halmazzal szemben, itt a 
            <varname>cc</varname> nem változik, hanem minden vizsgált z rácspontra ugyanaz, állandó lesz (a program eme változata 
            a Júlia halmaz része). A mi programunkban a függvény a kövztkezőképpen néz ki: z_n<superscript>3</superscript>+c. 
            A függűvény változtatásával a készített kép is fog változni.
        </para>     
                                 
        <para>
            Fordítás: <command>g++ biomorfok.cpp -lpng -O3 -o biomorfok</command> 
        </para>
        <para>
            Futtatás: <command>./biomorfok biomorf.png 800 800 10 -2 2 -2 2 .285 0 10</command>
        </para>
        <para>
            Kép megnyitása terminálból: <command>eog biomorf.png</command>
        </para>
        <figure>
            <title>Biomorf kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/biomorf.png" scale="40" />
                </imageobject>
                <textobject>
                    <phrase>Biomorf kép</phrase>
                </textobject>
            </mediaobject>
        </figure>                       
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
            <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
        <para>
            A feladatban tutorom volt Racs Tamás.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Mandelbrot/5.4/mandelpngc_60x60_100.cu">../Forraskodok/Mandelbrot/5.4/mandelpngc_60x60_100.cu</link>   
        </para>
        <programlisting>
<![CDATA[// mandelpngc_60x60_100.cu
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
//  Mandelbrot png
//  Programozó Páternoszter/PARP
//   https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux
//
//  https://youtu.be/gvaqijHlRUs
//

#include <png++/image.hpp>
#include <png++/rgb_pixel.hpp>

#include <sys/times.h>
#include <iostream>


#define MERET 600
#define ITER_HAT 32000

__device__ int
mandel (int k, int j)
{
  // számítás adatai
  float a = -2.0, b = .7, c = -1.35, d = 1.35;
  int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

  // a számítás
  float dx = (b - a) / szelesseg;
  float dy = (d - c) / magassag;
  float reC, imC, reZ, imZ, ujreZ, ujimZ;
  // Hány iterációt csináltunk?
  int iteracio = 0;

  // c = (reC, imC) a rács csomópontjainak
  // megfelelő komplex szám
  reC = a + k * dx;
  imC = d - j * dy;
  // z_0 = 0 = (reZ, imZ)
  reZ = 0.0;
  imZ = 0.0;
  iteracio = 0;

  while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
    {
      // z_{n+1} = z_n * z_n + c
      ujreZ = reZ * reZ - imZ * imZ + reC;
      ujimZ = 2 * reZ * imZ + imC;
      reZ = ujreZ;
      imZ = ujimZ;

      ++iteracio;

    }
  return iteracio;
}

__global__ void
mandelkernel (int *kepadat)
{

  int tj = threadIdx.x;
  int tk = threadIdx.y;

  int j = blockIdx.x * 10 + tj;
  int k = blockIdx.y * 10 + tk;

  kepadat[j + k * MERET] = mandel (j, k);
}

void
cudamandel (int kepadat[MERET][MERET])
{
  int *device_kepadat;
  cudaMalloc ((void **) &device_kepadat, MERET * MERET * sizeof (int));

  dim3 grid (MERET / 10, MERET / 10);
  dim3 tgrid (10, 10);
  mandelkernel <<< grid, tgrid >>> (device_kepadat);  
  
  cudaMemcpy (kepadat, device_kepadat,
	      MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
  cudaFree (device_kepadat);
}

int
main (int argc, char *argv[])
{
  // Mérünk időt (PP 64)
  clock_t delta = clock ();
  // Mérünk időt (PP 66)
  struct tms tmsbuf1, tmsbuf2;
  times (&tmsbuf1);

  if (argc != 2)
    {
      std::cout << "Hasznalat: ./mandelpngc fajlnev";
      return -1;
    }

  int kepadat[MERET][MERET];
  cudamandel (kepadat);
  png::image < png::rgb_pixel > kep (MERET, MERET);

  for (int j = 0; j < MERET; ++j)
    {
      //sor = j;
      for (int k = 0; k < MERET; ++k)
	{
	  kep.set_pixel (k, j,
			 png::rgb_pixel (255 -
					 (255 * kepadat[j][k]) / ITER_HAT,
					 255 -
					 (255 * kepadat[j][k]) / ITER_HAT,
					 255 -
					 (255 * kepadat[j][k]) / ITER_HAT));
	}
    }
  kep.write (argv[1]);

  std::cout << argv[1] << " mentve" << std::endl;

  times (&tmsbuf2);
  std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

  delta = clock () - delta;
  std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

}]]>
        </programlisting>
        <para>
            Ugynúgy mint a legelső Mandelbrotos feladat, a mandelbrot halmazt számolja ki, hasonló műveletekkel, 
            viszont van egy nagy különbség a kettő között: míg az első a CPU-t használja a számítások közben, addig ez a 
            program a GPU-t használja. A program futtatása után a számok melyek az időt mutatják magukért beszélnek. 
            Míg a CPU-t használó program 15 másodpercet vett igénybe, addig CUDA-s program mintegy 0.15 másodperc 
            alatt kiszámolja nekünk ugyanazt az eredményt. A két program leírásban nagyon hasonlít az előző feladathoz,
            mint mondtam itt a számítási idők mások, ezt az időt a program során számoljuk és iratjuk ki, hogy legyen ű
            vizsonyítási alapunk. Mivel nekem nincs CUDA kártyám ezért nem tudom élvezni ezt a gyors programfutás által
            gerjeszett élményeket, de a fent belinkelt videón mindez megtapasztalható.
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Mandelbrot/5.5/mandelbrotnagyito.cpp">../Forraskodok/Mandelbrot/5.5/mandelbrotnagyito.cpp</link>   
        </para> 
        
        <para>
            A Mandelbrot halmaz kiszámítása mellett ezzel a programmal a kiadott képen nagyítást is tudunk 
            végrehaktani. A kép megnyitása után az egerünk görgőjének segítségével tudunk benne nagyítani, illetve 
            touchpad-en a kétújjas mozdulattal.
        </para>      
  
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{
	int szelesseg = 1920;
	int magassag = 1080;
	int iteraciosHatar = 255;
	double a = −1.9;
	double b = 0.7;
	double c = −1.3;
	double d = 1.3;

	if ( argc == 9 )
	{
		szelesseg = atoi ( argv[2] );
		magassag = atoi ( argv[3] );
		iteraciosHatar = atoi ( argv[4] );
		a = atof ( argv[5] );
		b = atof ( argv[6] );
		c = atof ( argv[7] );
		d = atof ( argv[8] );
	}
	else
	{
		std::cout << "Hasznalat: ./3.1.1 fajlnev szelesseg magassag n a b c d" << std::endl;
		std::cout << "Most az alapbeallitasokkal futtatjuk " << szelesseg << " "
		<< magassag << " "
		<< iteraciosHatar << " "
		<< a << " "
		<< b << " "
		<< c << " "
		<< d << " " << std::endl;
		//return −1;
	}]]>
        </programlisting>
        <para>
            A program eleje ismerős hiszen úgyanaz mint az előző programok esetében: header fájlok dekalrálása, 
            majd a változók beadagolása (<varname>szelesseg</varname>, <varname>magassag</varname>, <varname>iteraciosHatar</varname>, <varname>a</varname>, 
            <varname>b</varname>, <varname>c</varname> és <varname>d</varname>). Most is megvizsgáljuk hogy a parancs 
            amivel a felhasználó futtatta a programot, az tényleg 9 argumentumból áll-e. Ha igen akkor az az egyes 
            argumentumokat, értékeket átadjuk az egyes változóknak, ha viszont az argumentumok száma nem felel meg, 
            akkor használati utasítást adunk a programot futtatónak hogy mi lenne a helyes mód, illetve még segítségképp 
            megmutatjuk azt is hogy mik voltak az általunk adott alap beállítások. 
        </para>
        <programlisting language="c++">
<![CDATA[	png::image < png::rgb_pixel > kep ( szelesseg, magassag );

	double dx = ( b − a ) / szelesseg;
	double dy = ( d − c ) / magassag;
	double reC, imC, reZ, imZ;
	int iteracio = 0;
	
	std::cout << "Szamitas\n";
	
	for ( int j = 0; j < magassag; ++j )
	{
		for ( int k = 0; k < szelesseg; ++k )
		{
			reC = a + k * dx;
			imC = d − j * dy;
			std::complex<double> c ( reC, imC );
			
			std::complex<double> z_n ( 0, 0 );
			iteracio = 0;
			
			while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
			{
				z_n = z_n * z_n + c;

				++iteracio;
			}

			iteracio %= 256;

			kep.set_pixel ( k, j,
			png::rgb_pixel ( iteracio%255, 0, 0 ) );
		}

		int szazalek = ( double ) j / ( double ) magassag * 100.0;
		std::cout << "\r" << szazalek << "%" << std::flush;
	}

	kep.write ( argv[1] );
	std::cout << "\r" << argv[1] << " mentve." << std::endl;
	
}]]>
        </programlisting>
        <para>
            A program utolsó része ugynőgy komplexszámos megoldásssal van csinálva. A két for cuklussal végigmegyünk 
            a rácson <varname>j</varname>-vel a soron, <varname>k</varname>-val az oszlopon. A a <varname>reC</varname>,
            <varname>imC</varname>, <varname>reZ</varname> és <varname>imZ</varname> (valós és imaginárius részű) változókat
            használva végigmegyünk minden rácsponton úgy, hogy a c=(reC, imC) a haló rácspontjainak megfelelő komplex szám.
            A megadott képletet használva megalkotjuk a várt képet, megkapjuk a "mentve" üzenetet, megnyitjuk a képet 
            és tetszésünk szerint nagyítgathatunk a kapott képben aszerint ahogy a feladat legelején bemutattam. 
        </para>
        
        <para>
            Fordítás: <command>g++ mandelbrotnagyito.cpp -lpng16 -O3 -o mandelbrotnagyito</command> 
        </para>
        <para>
            Futtatás: <command>./mandelbrotnagyito mandelnagyitocpp.png 1920 1080 1020 0.41276554182095892553405747094075195491310.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874</command>
        </para>
        <para>
            Kép megnyitása terminálból: <command>eog mandelnagyitocpp.png</command>
        </para>
        <figure>
            <title>C++ mandelbrot nagyító és utazó</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelnagyitocpp.png" scale="25" />
                </imageobject>
                <textobject>
                    <phrase>C++ mandelbrot nagyító és utazó</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
        <para>
            A program célja ugyanaz mint az előző programé: nagyítsunk a kapott képben. A java-s program úgy van megírva, 
            hogy itt a bal egérgomb segítségével kell kijelöljük azt a részt amt pontosabban, "közelebbről" megszeretnénk 
            tekinteni. Ezt a műveletet nagyon sokszor tudjuk megcsinálni egymás után. A programban commentként rengeteg 
            magyarázatot találunk, melyek a különböző sorok, parancsok mülködését írják le.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Mandelbrot/5.6/MandelbrotHalmazNagyito.java">../Forraskodok/Mandelbrot/5.6/MandelbrotHalmazNagyito.java</link>   
        </para> 
        <programlisting language="java">
<![CDATA[/*
 * MandelbrotHalmazNagyító.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt nagyító és kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class MandelbrotHalmazNagyító extends MandelbrotHalmaz {
    /** A nagyítandó kijelölt területet bal felső sarka. */
    private int x, y;
    /** A nagyítandó kijelölt terület szélessége és magassága. */
    private int mx, my;
    /**
     * Létrehoz egy a Mandelbrot halmazt a komplex sík
     * [a,b]x[c,d] tartománya felett kiszámoló és nygítani tudó
     * <code>MandelbrotHalmazNagyító</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
     * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
     * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
     * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
     * @param      szélesség      a halmazt tartalmazó tömb szélessége.
     * @param      iterációsHatár a számítás pontossága.
     */
    public MandelbrotHalmazNagyító(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent m) {
                x = m.getX();
                y = m.getY();
                mx = 0;
                my = 0;
                repaint();
            }
            public void mouseReleased(java.awt.event.MouseEvent m) {
                double dx = (MandelbrotHalmazNagyító.this.b
                        - MandelbrotHalmazNagyító.this.a)
                        /MandelbrotHalmazNagyító.this.szélesség;
                double dy = (MandelbrotHalmazNagyító.this.d
                        - MandelbrotHalmazNagyító.this.c)
                        /MandelbrotHalmazNagyító.this.magasság;
                new MandelbrotHalmazNagyító(MandelbrotHalmazNagyító.this.a+x*dx,
                        MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                        MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                        MandelbrotHalmazNagyító.this.d-y*dy,
                        600,
                        MandelbrotHalmazNagyító.this.iterációsHatár);
            }
        });]]>
        </programlisting>
        <para>
            A program elején úgyanúgy mint ahogy megszoktuk jönnek a változók deklarálásai, ahol az <varname>x</varname>
            és az <varname>y</varname> változókkal határoljuk be a nagyítandó terület bal felső sarkát, illetve az 
            <varname>mx</varname> és <varname>my</varname> pedig a kijelölt nagyítandó terület magassága és szélessége.
            vjuk az ős osztály konstruktorát, beállítjuk az ablak címét (amiben majd nagyítunk) és deklaráljuk az egér 
            kattintás müveletét. Az azonnal következő <function>mousePressed</function> függvény segítségével deklaráljuk 
            a nagyítandó terület bal felső sarkát, szélességé és magasságát. A következő <function>mouseReleased</function> 
            függvénnyel az a művelet aktivizálódik, amikor kattintjuk az egeret, vonszolással kijelöljük a nagyítani kívánt 
            területet és amikor elengedjük az egérgombot akkor a kijelölt terület újraszámítása kezdődik el, illetve megalkotódik 
            a kinagyított terület, az lesz az aktuális kép amit az ablakban látunk és továbbnagyítunk majd.
        </para>

        <programlisting language="java">
<![CDATA[        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent m) {
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }]]>
        </programlisting>
        <para>
            Itt deklaráljuk a fentebb már használt függvényt, ami arra szolgál hogy követni lehessen a 
            eglr mozgását, kattintásának feldolgozását, a kijelölés menetét mindazáltal hogy közben 
            megadjuk a <function>mouseDragged</function> föggvényt (ami nem más mint a vonszolás, a 
            kijelölés menete, az új szélesség és a magasság bellítása és az újraméretezés által).
        </para>
        
        <programlisting language="java">
<![CDATA[    public void pillanatfelvétel() {
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
        g.dispose();        
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }]]>
        </programlisting> 
        <para>
            Mint a sima nagyítás nélküli programban, itt is lehetővé tesszük a felhasználó számára 
            a pillanatfelvétel készítésének a lehetőségét. Ebben az esetben figyelme vesszük azt is, 
            hogy az adott képernyőfotó hányadik volt, mivel hogy könnyebben tudjunk majd eligazodni a 
            képek között, a kép nevében szerepelni fog hogy mikor csináltuk azt, hányadikként.
            A fájl nevébe belevesszük, hogy melyik tartományban találtuk a halmazt:
        </para>
    
        <programlisting language="java">
<![CDATA[    public void paint(java.awt.Graphics g) {
         g.drawImage(kép, 0, 0, this);         
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
    }

    public static void main(String[] args) {
        new MandelbrotHalmazNagyító(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}]]>
        </programlisting> 
        <para>
            A <function>paint</function> segítségével legelőször is kirajzoljuk a Mandelbrot halmazt.
            Ha a számítások éppen futnak, akkor azt hogy melyik sorban tart egy vörös csíkkal jelöljük. 
            Végül pedig kirajzoltatjuk a nagyítandó terület körvonalát zöld színnel.
        </para>
        
        <para>
            Fordítás: <command>javac MandelbrotHalmazNagyító.java</command> 
        </para>
        <para>
            Futtatás: <command>java MandelbrotHalmazNagyító</command>
        </para>
        <figure>
            <title>Java mandelbrot nagyító és utazó</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelnagyitojava.png" scale="45" />
                </imageobject>
                <textobject>
                    <phrase>Java mandelbrot nagyító és utazó</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <figure>
            <title>Többszöri nagyítás után</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/nagyitasjava.png" scale="45" />
                </imageobject>
                <textobject>
                    <phrase>Többszöri nagyítás után</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>      
