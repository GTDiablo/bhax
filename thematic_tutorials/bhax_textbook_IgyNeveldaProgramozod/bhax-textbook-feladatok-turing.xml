<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
        Szerintem a kód és amit csinál nagyon egyértelmű volt és reészletesen is dokumentáltam a könyvben, ezért egyéb alámondást nem igényel a videó.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/GoR2cJ9vzZc">https://youtu.be/GoR2cJ9vzZc</link>
        </para>
        <para>
            C végtelen ciklus, mely 0 százalékban dolgoztat egy magot.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.1/vegtelen1.c">../Forraskodok/Turing/2.1/vegtelen1.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <unistd.h>

int main ()
{
	for (;;)
		sleep (1);
	return 0;
}]]> 
        </programlisting>
        
        <para>
            Fordítás: <command>gcc vegtelen1.c -o vegtelen1</command> 
        </para>
        <para>
            Futtatás: <command>./vegtelen1</command>
        </para>
        <para>
            Tudjuk, hogy a for ciklusban ;-vel válsztjuk el a felsorolást. Mint latjuk a programrészletben ezek hiányoznak, 
            ezért alakul ki a végtelen ciklus, egy ciklus mely sosem áll le, amit mi kell leállitsuk, megöljünk (kill). A for ciklusunk egyetlen
            egy parancsot tartalmaz, ez a <command>sleep</command> parancs ami miatt a program 0 százalékban mozgatja a magot, 
            a paracsról a <command>man 3 sleep</command> kézikönyvből többet is megtudhatunk.   
        </para> 
        <para>
            Minden esetben, a program futtatása után, lekérünk egy <command>top</command> parancsot, hogy megnézzük a tényleges használatot (a top-on belül az 1-es gomb lenyomásával láthatóvá
            válik az összes mag).
        </para>
        <figure>
            <title>0%-os magmozgatás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/vegtelen1.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>0%-os magmozgatás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
            Felül a CPU-knál látjuk, hogy mindegyik nagyon közel van a 0-hoz. A listázott részben pedig azért nem jelenik meg a 
            programunk, mert a magmozgatás szempontjából csökkenő sorrendbe van rendezve a lista (de a lista végére görgetve láthtjuk azt is). 
        </para>
        
        <para>
            C végtelen ciklus, mely 100 százalékban dolgoztat egy magot.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.1/vegtelen2.c">../Forraskodok/Turing/2.1/vegtelen2.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>

int main() {
	for (;;) 
	{
		;
	}
}]]> 
        </programlisting>
        <para>
            Fordítás: <command>gcc vegtelen2.c -o vegtelen2</command>
        </para>
        <para>
            Futtatás: <command>./vegtelen2</command>
        </para>
        <para>
            A programban mint látjuk a for ciklusban nincs sem feltétel, sem elvégezendő utasítás (;), ezért alakul ki a végtelen ciklus.
            A <command>top</command> parancs futtatása után látjuk hogy egy magot mozgat csak, de azt 100%-on. A lista részben viszont az előző
            példával szemben, most a lista élén jelenik meg a programunk, jelezve a 100%-os magmozgatást.
        </para>  
        <figure>
            <title>100%-os magmozgatás egy mag esetén</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/vegtelen2.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>100%-os magmozgatás egy mag esetén</phrase>
                </textobject>
            </mediaobject>
        </figure>
        
        <para>
            C végtelen ciklus, mely 100 százalékban dolgoztat minden magot.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.1/vegtelen3.c">../Forraskodok/Turing/2.1/vegtelen3.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>
#include <omp.h>

int main() {
	#pragma omp parallel
	{
            for (;;) 
                ;
	}
	return 0;
}]]> 
        </programlisting>
        <para>
            Fordítás: <command>gcc vegtelen3.c -o vegtelen3 -fopenmp</command>
        </para>
        <para>
            Futtatás: <command>./vegtelen3</command>
        </para>
        <para>
            A for ciklus ugyanúgy működik mint az előző példákban. A <command>#pragma omp parallel</command> parancs egy szálcsoportot hoz létre 
            és amikor fut a végtelen ciklus váltogatja ezeket a szálakat. Majd újabb <command>top</command>-al megnézzük.
        </para>
        <para>
            Mint látjuk, mind a három végtelen ciklust for ciklussal csináltuk meg. A végtelen ciklusok másik elterjedt változata a <command>while(1)</command>
            kezdetű parancs, ami azért nem a leghelyesebb, mivel a végtelen ciklusokat véletlenől is elő lehet állítani egy rosszul futó programmal, tehát programhiba
            is lehet. Ezért hogyha szándkosan akarunk végtelen ciklust generálni, akkor ajánlatosabb a <command>for(;;)</command>-ot használni, mert ebből
            jól kivehető hogy ez is volt a szándék.
        </para>
        <figure>
            <title>100%-os magmozgatás az összes mag esetén</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/vegtelen3.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>100%-os magmozgatás az összes mag esetén</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            Itt már látszik hogy minden mag sorában megjelenik a 100% érték, mely azt jelenti, hogy sikerült elérnünk azt hogy a program minden magot 
            egyszerre mozgasson. A listás résznél az élen újra a végtelen program van, a közel 400-as értékkel sugallva, hogy mind a 4 mag mozog. 
        </para>
                 
    </section>      
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            Egy kép, mely illusztrálja a feltételezett program működését:   
        </para>
        <figure>
            <title>T100</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/T100.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>T100</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <para>
            Egy újabb ilusztráció a program működéséről:
        </para>
        <figure>
            <title>T1000</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/T1000.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>T1000</phrase>
                </textobject>
            </mediaobject>
        </figure>                      
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tehát, feltételezések alapján bebizonyítottuk, hogy akár mekkora hackerek legyünk , nem lehet ilyen programot írni. A T100-as program lefut 
            és el is dönti hogy a betáplált programról, hogy lefagyó program e, helyesen adja vissza a true és a false értékeket. Viszont a T1000-es esetén 
            már ellentmondásba ütközünk, mivel amikor saját magát kapja paraméterül akkor elég más eredményeket ad mint amire várunk.
            Amikor a T1000-es egy lefagyó program lesz, akkor a vegén nem fog lefagyni, hanem a true értéket fogja visszaadni. Ellenkező esetben pedig, amikor 
            a T1000 nem egy lefagyó program, akkor le fog fagyni, vagyis a false értéket kapjuk. Ez az ellentmondás arra ad bizonyítékot, hogy egy ilyen program 
            még ha meg is lehetne írni, akkor se mülködne. 
             
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
        Szerintem a kód és amit csinál nagyon egyértelmű volt és reészletesen is dokumentáltam a könyvben, ezért egyéb alámondást nem igényel a videó.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/f23nJjxGl7k">https://youtu.be/f23nJjxGl7k</link>
        </para>
        <para>
            Megoldás forrása:   <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Ezt a feladatot háromféle példával fogom illusztrálni (egyikben sem használva segédváltozót).
            A prgram mindegyik esetben a 3-as és a 8-as értéket fogja felcserélni (de természetesen más számokkal is működik), 
            az elején kiiratja az eredeti, a végén pedig a megváltoztatott értékeket. A számolás menete mind a három esetben követhető lesz 
            a programrészletben.
        </para>
        <para>
            Az első program a legegyszerübb műveletekkel, összeadással és kivonással végzi el a változócserét. 
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.3/valtcserkul.c">../Forraskodok/Turing/2.1/valtcserkul.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>

int main()
{
	int a=3;
	int b=8;
	printf("Eredeti ertekek:");
	printf("\na=%d", a);
	printf("\nb=%d", b);

        a = a+b;    //a=3+8=11
        b = a-b;    //b=11-8=3
        a = a-b;    //a=11-3=8

	printf("\nMegvaltoztatott ertekek:");
	printf("\na=%d", a);
	printf("\nb=%d", b);
	printf("\n");
	return 0;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc valtcserkul.c -o valtcserkul</command> 
        </para>
        <para>
            Futtatás: <command>./valtcserkul</command>
        </para>
        <para>
            A program elején deklarálunk két változót, ezeket ki is íratjuk a standard kimenetre, hogy a felhasználó tudja ellenőrizni a 
            program mülködését. Majd elvégezzük a változócserét. A három program leírása során csak a változók cseréjének a módszere fog 
            különbözni, a többi úgyanaz. A műveletek elvégeztével kiíratjuk a felhasználó számára a felcserélt értékeket is, bizonyítva 
            a program helyességét.
        </para>
        
        <para>
            A második program a szorzás és osztás segítségével cseréli meg a változók értékeit.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.3/valtcserszor.c">../Forraskodok/Turing/2.3/valtcserszor.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>

int main()
{
	int a=3;
	int b=8;
	printf("Eredeti ertekek:");
	printf("\na=%d", a);
	printf("\nb=%d", b);

        a=a*b;  //a=3*8=24
        b=a/b;  //b=24/8=3
        a=a/b;  //a=24/3=8

	printf("\nMegvaltoztatott ertekek:");
	printf("\na=%d", a);
	printf("\nb=%d", b);
	printf("\n");
	return 0;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc valtcserszor.c -o valtcserszor</command> 
        </para>
        <para>
            Futtatás: <command>./valtcserszor</command>
        </para>

        <para>
            Végül pedig a harmadik programban, amelyik az exor(xor) művelettel hajtja végre a változócserét.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.3/valtcserexor.c">../Forraskodok/Turing/2.3/valtcserexor.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>

int main()
{
	int a=3;    //a=0011
	int b=8;    //b=1000
	printf("Eredeti ertekek:");
	printf("\na=%d", a);
	printf("\nb=%d", b);

	a=a^b;  //a=0011^1000=1011
	b=a^b;  //b=1011^1000=0011
	a=a^b;  //a=1011^0011=1000

	printf("\nMegvaltoztatott ertekek:");
	printf("\na=%d", a);
	printf("\nb=%d", b);
	printf("\n");
	return 0;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc valtcserexor.c -o valtcserexor</command> 
        </para>
        <para>
            Futtatás: <command>./valtcserexor</command>
        </para>
        <para>
            A xor művelet, másképp kizáró vagy, egy bitművelet. Két egyforma hosszúságú bitsorozaton végzi el a kizáró vagy műveletet,
            ami annyiból áll, hogy ahol megegyezik a bitek értéke ott 0-át ad eredményül, ahol pedig eltér ott 1-et.
        </para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/qHB1u2OdSxY">https://youtu.be/qHB1u2OdSxY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        
        <para>
            Labdapattogtatás if-el
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.4/labda1.c">../Forraskodok/Turing/2.4/labda1.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>
#include <curses.h>
#include <unistd.h>

int
main ( void )
{
    WINDOW *ablak;
    ablak = initscr ();
    
    int x = 0;
    int y = 0;

    int xnov = 1;
    int ynov = 1;

    int mx;
    int my;]]>
        </programlisting>
        <para>
            A program elején egy curses nevű header fájlt deklarálunk, ami lehetővé teszi az olyan függvények egyszerű meghivását
            mint például a <function>WINDOW</function>, az <function>initscr</function> stb.
            Ezek a függvények mind az ablak (melyben majd a labda pattogni fog) beállításokról, műveletekről felelnek (méret, az ablak inicializálása, 
            output kirajolása az ablakba, stb).
        </para>
        <para>
            A header fájlok felsorolása után jöhet a program többi része. A fenti programrészletben a <command>WINDOW</command> paranccsal 
            létrehozzuk azt az ablakot amelyikben a labdát fogjuk pattogtatni, majd inicilizáljuk azt (<command>initscr</command>). Az x, y tengely mentén
            rajzolódik majd ki a kis labda, ehhez változókat deklarálunk és kezdeti értékeket adunk meg a labda kezdeti pozíciójának.
        </para>
    
        <programlisting language="c">
<![CDATA[
        for ( ;; ) {

        getmaxyx ( ablak, my , mx );

        mvprintw ( y, x, "o" );

        refresh ();
        usleep ( 100000 );]]>
        </programlisting>
        <para>
            Mint látjuk, a nemrég megírt programok egyikét felhasználva, egy végtelen ciklust hozunk létre, ez fogja tartalmazni a labda
            pattogtatásával kapcsolatos információkat, mozgatási feltételeit. A <command>getmaxyx</command> függvénnyel meghatározzuk az 
            ablak méreteit, hogy hol és mennyi távolságot pattogjon a labda. A <command>mvprintw</command> függvény fogja kirajzolni a mi 
            labdánkat a képernyőre, minden rajzolás után frissitve állapotát (<command>refresh</command>). Az <command>usleep</command> 
            paranccsal pedig a labda pattogási, mozgási sebességét tudjuk megadni.
        </para>
        
        <programlisting language="c">
<![CDATA[
        x = x + xnov;
        y = y + ynov;

        if ( x>=mx-1 ) {    // elerte-e a jobb oldalt?
        xnov = xnov * -1;
        }
        if ( x<=0 ) {       // elerte-e a bal oldalt?
        xnov = xnov * -1;
        }
        if ( y<=0 ) {       // elerte-e a tetejet?
        ynov = ynov * -1;
        }
        if ( y>=my-1 ) {    // elerte-e a aljat?
        ynov = ynov * -1;
        }
        }
        return 0;
}]]>
        </programlisting>
        <para>
            A program utolsó felében azokat az eseteket tárgyaljuk amikor a labda eléri az ablak valamelyik szélét (a commnetekkel 
            jelölve hogy éppen melyik szélre utal), amikor a labda eléri a keretet. A négy darab if a négy szél tárgyalása.
        </para>
        <para>
            Fordítás: <command>gcc labda1.c -o labda1 -lncurses</command> 
        </para>
        <para>
            Futtatás: <command>./labda1</command>
        </para>
        
        <para>
            Labdapattogtatás is nékül
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.4/labda2.c">../Forraskodok/Turing/2.4/labda2.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <curses.h>
#include <unistd.h>

int
main (void)
{
    int xj = 0, xk = 0, yj = 0, yk = 0;
    int mx = 80 * 2, my = 24 * 2;

    WINDOW *ablak;
    ablak = initscr ();

    for (;;)
    {
        xj = (xj - 1) % mx;
        xk = (xk + 1) % mx;

        yj = (yj - 1) % my;
        yk = (yk + 1) % my;

        clear ();

        mvprintw (0, 0,
                  "--------------------------------------------------------------------------------");
        mvprintw (24, 0,
                  "--------------------------------------------------------------------------------");
        mvprintw (abs ((yj + (my - yk)) / 2),
                  abs ((xj + (mx - xk)) / 2), "o");

        refresh ();
        usleep (150000);
    }
    return 0;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc labda2.c -o labda2 -lncurses</command> 
        </para>
        <para>
            Futtatás: <command>./labda2</command>
        </para>
        <para>
            A labdapattogtatás if nélküli megoldása már nem érvényes minden nagyságú ablakra, a szaggatott vonalak segítségével fogjuk 
            behatárolni majd azt. A program felépítése hasonló az előzőjéhez, a header fájlok után a főprogram, abban változó deklarálások 
            (melyek az ablak kinézetének és a labda helyzetének a meghatározásához kellenek), az ablak létrehozása amelyikben majd a labda 
            mozog. A for ciklus segítségével üjra készítünk egy végtelen ciklust, hogy a labdapattogtatás újra addig tartson, amíg mi le 
            nem állítjuk. Mint ahogy a program neve is mutatja, if nélküli labdapattogtatás, nincs benne if, tehát a pattogtatás bármiféle 
            logikai utasítás vagy kifejezés használata nélkül megy végbe. A labda adott (jelenlegi) helyzetét elosztjuk az ablak méretével 
            (szélességet szélességgel, magasságot magassággal, vagyis az x-eseket az <varname>mx</varname>-el, az y-osokat az <varname>my</varname>-al) 
            és hogyha ennek az osztásnak a maradéka 0, akkor a labda elérte az adott szélt és itt az ideje hogy visszaforduljon. A továbbiakban 
            űhasznált három fuggvény az if-es labdapattogtatásban már be vannak mutatva.
        </para>
        
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/RMR5URhR1Vw">https://youtu.be/RMR5URhR1Vw</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>
        </para>
        <para>
            Elsősorban vizsgáljunk meg egy olyan programot, amelyik megnézi, hogy hány bites a szó a gépünkön, azaz mekkora az <type>int</type> mérete, a <command>sizeof</command> segítségével.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.5/szohossz.c">../Forraskodok/Turing/2.5/szohossz.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>

int main()
{
	printf("%ld\n", sizeof(int)*8);
	return 0;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc szohossz.c -o szohossz</command> 
        </para>
        <para>
            Futtatás: <command>./szohossz</command>
        </para>
        <para>
            Végeredményül a 32-t kapjuk. Az eredményt a <function>sizeof()</function> segítségével kapjuk meg, melyben megnézzük hogy mennyi  
            az int hossza, a kapott értéket megszorozzuk 8-al mivel így az eredményt bitben kapjuk meg, nem pedig bájtban. 
        </para>
        
        <para>
            A második program ugyancsak a szóhosszt nézi meg, annyi különbséggel, hogy ez bitműveletes módszerrel.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.5/szohossz2.c">../Forraskodok/Turing/2.5/szohossz2.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>

int main(void)
{
	int h = 0;
	int n = 0x01;
	do
	++h;
	while(n<<=1);
		printf("A szohossz ezen a gepen: %d bites\n", h);
	return 0;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc szohossz2.c -o szohossz2</command> 
        </para>
        <para>
            Futtatás: <command>./szohossz2</command>
        </para>
        <para>
            Az n változót egy hexadecimális számmal deklaráljuk. Majd egy hátultesztelős do-while ciklussal növeljük h értékét minden lépésnél, 
            a while-ban egy helyiérték eltolás van balra, ez a feltétel akkor vális hamissá, amikor a h eléri a 32 bitet.
            A végeredmény a következő lesz: A szohossz ezen a gepen: 32 bites.  
        </para>
        
        <para>
            Végül pedig nézzük hogy mi is az a BogoMIPS.
        </para>
        <para>
            A BogoMIPS a "Bogus MIPS"-ből származik (bogus=hamis). A MIPS rövidítésnek két megfelelője is elterjedt a köztudtaban. Az első a Meaningless Indication of Processor Speed (a processzor sebességének értelmetlen jellemzése), 
            ami annyit tesz, hogy a processzor a másodperc egyik milliomodnyi részében sem csinál semmit.
            Az második értelmezése a Million Instructions Per Second (millió utasítás/művelet másodpercenként), mely alatt a számítógép számítási sebességét értjük. 
            A BogoMIPS Linus Torvalds találmánya. A rendszerindítás (bootolás) során a kerner megméri, hogy egy bizonyos ciklusnak mennyi a futási ideje. Tehát mint a nevének leírásában is,
            a BogoMIPS eredményből következtetni tudunk a processzor sebességére, de ez annyira ál, már-már megalapozatlan, tudománytalan, hogy csak a BogoMIPS kifejezés illet rá.
            A BogoMIPS eredmények többnyire 386 és 586 között vannak, ha az eredmény ez az intervallum alatt van (htehát kisebb mint 386), akkor a CPU sebesség vagy a Turbó gomb nincs megfelelően, optimlisan beállítva.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.5/bogomips.c">../Forraskodok/Turing/2.5/bogomips.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <time.h>
#include <stdio.h>

void
delay (unsigned long long int loops)
{
    unsigned long long int i;
    for (i = 0; i < loops; i++);
}

int
main (void)
{
    unsigned long long int loops_per_sec = 1;
    unsigned long long int ticks;

    printf ("Calibrating delay loop..");
    fflush (stdout);

    while ((loops_per_sec <<= 1))
    {
        ticks = clock ();
        delay (loops_per_sec);
        ticks = clock () - ticks;

        printf ("%llu %llu\n", ticks, loops_per_sec);

        if (ticks >= CLOCKS_PER_SEC)
        {
        loops_per_sec = (loops_per_sec / ticks) * CLOCKS_PER_SEC;

        printf ("ok - %llu.%02llu BogoMIPS\n", loops_per_sec / 500000,
        (loops_per_sec / 5000) % 100);

        return 0;
        }
    }
    
printf ("failed\n");
return -1;
}]]>
        </programlisting>
        <para>
            Fordítás: <command>gcc bogomips.c -o bogomips</command> 
        </para>
        <para>
            Futtatás: <command>./bogomips</command>
        </para>
        <para>
            A <function>delay</function> segít lemérni az elvégzéshez szükséges időt. A while feltételében <function>loop_per_sec</function> értéke minen ciklus kezdeténél
            egyel balra lesz tolva, tehát a ciklus csak túlcsordultság vagy az if igazsága miatt fog leállni. A ciklusban a <varname>ticks</varname> először az aktuális, 
            majd az eltelt időt fogja tárolni. Majd kiiratódik a <varname>ticks</varname> és a <function>loop_per_sec</function> aktuális értéke. Ha bekövetkezik az, hogy az if feltétele 
            igaz lesz, tehát ha a <varname>ticks</varname> nagyobb vagy egyenlővé válik mint a <constant>CLOCKS_PER_SEC</constant> akkor a program elér a végéhez és kiírja a BogoMIPS eredményt 
            a képernyőre. Az utolsó két sor csak akkor lesz végrehajtva, ha az if feltétele sosem lesz igaz.
        </para>
        <figure>
            <title>BogoMIPS eredménye nálam</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/bogomips.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>BogoMIPS eredménye nálam</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            Ahogy a csatolt képen is látszik végeredményül 1086-at kaptam, ami annyit jelent, hogy az én gépem 1 másodperc alatt 1086 millió 
            utasítást tud végrehajtani.  
        </para>
        
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/PZ5mnm4XAWM">https://youtu.be/PZ5mnm4XAWM</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            A PageRank egy nagyon elterjedt algoritmus az informtikában. Az algoritmust  Larry Page és Sergey Brin, a Google alapítói irták 1998-ban a Stanford Egyetemen. 
            Az algoritmus és ezáltal a Google internetes kereső is arra a feltevésre épül, hogy a weboldalak készítői azokra a weblapokra hivatkoznak a saját oldalukról, 
            amit jónak tartanak. Ez hasonlít egy szavazáshoz: a hivatkozások az adott oldalra (tehát minden hiperlink) egyfajta szavazatnak számítanak. 
            A hivatkozások mellett fontos szerepet játszik még az, hogy annak az oldalnak ami hivatkozott, ami leadta a szavazatát, annak hány szavazata van, tehát milyen fontos. 
            Itt kialakul egyfajta rekúrzív folyamat: az az oldal számít fontonak, amelyikre olyan oldalak mutatnak amik fontosak.
        </para>
        <para>
            Kezdetben minden oldalnak van valamennyi szavazata, illetve azok a szavazatok amiket más oldalaktól kapnak. Ezeket egyenlően szétoszt azok az oldalak között amikre majd ő hivatkozik.
            Az oldal PageRank értéke megegyezik a kapott szavazatok számával. Hogy minden jól menjen be kell vezetni egy csillapító erőt, tényezőt, amelyik arról felel, hogy a saját szavazatuk (1-d) 
            része maradjon meg az oldalnak, d részét pedig továbboszthat. Ezért a következő a képletet lehet felírni:
        </para>
        <figure>
            <title>PageRank képlet</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/prkeplet.png" scale="65" />
                </imageobject>
                <textobject>
                    <phrase>PageRank képlet</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            ahol az M(i) az i. oldalra hivatkozó oldalaknak a száma, az L(j) pedig a j. oldalról kimenő hivatkozásoknak a száma.
        </para>
        <para>
            Mindezen ismertetők után lássuk a programot, amelyik kiszámolja ezt az értéket.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.6/pagerank.c">../Forraskodok/Turing/2.6/pagerank.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>
#include <math.h>

void
kiir (double tomb[], int db){
	
	int i;
	
	for (i=0; i<db; ++i){
		printf("%f\n",tomb[i]);
	}
}]]>
        </programlisting>
        <para>
            A program elején deklarálunk néhány olyan függvényt. Ilyen a <function>kiir</function> függvény is, melynek külön való megírása egyszerűsíti
            a dolgunkat és sokkal átláthatóbbá teszi a programunkat. A <function>kiir</function> függvénnyel egy egydimenziós tömböt, vagyis egy vektort
            tudunk majd kiiratni, minden elemét új sorba íratva.
        </para>

        <programlisting language="c">
<![CDATA[double
tavolsag (double PR[], double PRv[], int n){
	
	int i;
	double osszeg=0;
	
	for (i = 0; i < n; ++i)
		osszeg += (PRv[i] - PR[i]) * (PRv[i] - PR[i]);
	
	return sqrt(osszeg);
}]]>
        </programlisting>
        <para>
            A <function>tavolsag</function> nevű függény három paramétert kap, két egydimenziós tömböt és egy <varname>n</varname>-t, ami a tömbök 
            méretét jelöli. A távolság számítása a következőképpen történik: mindkét tömbböl kivonjuk egymásból az egyforma indexű elemeket, ezeket 
            a négyzetre emeljük, majd a kapott értéket hozzáadjuk egy <varname>osszeg</varname> nevű változóhoz (az <varname>osszeg</varname>-ben 
            <varname>n</varname> darab érték összege lesz). A függvény visszatérítési értéke pedig ennek az összegnek a gyöke lesz.
        </para>

        <programlisting language="c">
<![CDATA[void
pagerank(double T[4][4]){
	double PR[4] = { 0.0, 0.0, 0.0, 0.0 };		//ebbe megy az eredmény
	double PRv[4] = { 1.0/4.0, 1.0/4.0, 1.0/4.0, 1.0/4.0};		//ezzel szorzok
	
	int i, j;
	
	for(;;){	
        // ide jön a mátrix művelet		
		for (i=0; i<4; i++){
			PR[i]=0.0;
			for (j=0; j<4; j++){
				PR[i] += T[i][j] * PRv[j];
			}
		}
	
                if (tavolsag(PR,PRv,4) < 0.0000000001) 
                    break;
		
		// ide meg az átpakolás PR-ből PRv-be
		for (i=0;i<4; i++){
			PRv[i]=PR[i];
		}	
	}
	
	kiir (PR, 4);
}]]>
        </programlisting>
        <para>
            A <function>pagerank</function> függvény az ami elvégzi nekünk a mátrixszorzást és visszatéríti a szorzás eredményét. A paraméterül 
            kapott T kétdimenziós tömb az amit mi a main-ben megadunk, a függvény ezt szorozza össze a PRv tömbbel, mely az oldalak első iterációbeli értékeit tartalmazza, az eredmény pedig a PR-be fog kerülni.
            Matematikai szemszögből a helyes megfogalmazás az lenne hogy a PRv-t szorozzuk a T-vel mivel a mátrixszorzás szabalyit figylembe véve 
            csak így végezhető el a mátrixszorzás, vagyis egy 1x4-es mátrix szorzása egy 4x4-es mátrixal egy 1x4-es mátrixot ad eredményül (másképp mondva 
            egy egydimenziós tömböt). Kezdünk egy végtelen ciklust, jön a mátrixszorzás majd megvizsgáljuk az PR (eredmény mátrix) és a PRv közötti távolságot,
            ha ez az érték kisebb mint 0.0000000001, akkor a <function>break</function> fügvénnyel kilépünk a végtelen ciklusból, ha pedg nem akkor a PRv-ben lévő értékeket lecseréljük az eredmátrixban 
            lévő értékekkel és a következő körben a mi általunk megadott mátrixot ezzel fogjuk szorozni. 
        </para>

        <programlisting language="c">
<![CDATA[int main (void){
	double L[4][4] = {
		{0.0,  0.0,      1.0/3.0,  0.0},
		{1.0,  1.0/2.0,  1.0/3.0,  1.0},
		{0.0,  1.0/2.0,  0.0,      0.0},
		{0.0,  0.0, 	 1.0/3.0,  0.0}
	};	
	
	double L1[4][4] = {
		{0.0,  0.0,      1.0/3.0,  0.0},
		{1.0,  1.0/2.0,  1.0/3.0,  0.0},
		{0.0,  1.0/2.0,  0.0,      0.0},
		{0.0,  0.0, 	 1.0/3.0,  0.0}
	};
	
	double L2[4][4] = {
		{0.0,  0.0,      1.0/3.0,  0.0},
		{1.0,  1.0/2.0,  1.0/3.0,  0.0},
		{0.0,  1.0/2.0,  0.0,      0.0},
		{0.0,  0.0, 	 1.0/3.0,  1.0}
	};
	
	printf("\nAz eredeti mátrix értékeivel történő futás:\n");
	pagerank(L);
	
	printf("\nAmikor az egyik oldal semmire sem mutat:\n");
	pagerank(L1);
	
	printf("\nAmikor az egyik oldal csak magára mutat:\n");
	pagerank(L2);
	
	printf("\n");

	return 0;
}]]>
        </programlisting>
        <para>
            A főprogramban már csak annyi dolgunk van, hogy megadjuk a kezdeti mátrixokat az L-t, L1-et és az L2-t. Az L kétdimenziós mátrix tartalmazza 
            a linkelési adatokat, tehét hogy melyik oldal melyik oldalra hivatkozik. Az L1 esetén azt az esetet tudjuk megtekinteni amikor az egyik 
            oldal semmire sem mutat, az L2 esetén pedig azt amikor az egyik oldal csak magára mutat. Ezeket a mátrixot beküldjük a <function>pagerank</function>
            függvénybe, ott minden müvelet elvégződik, az eredmény pedig kiiratódik a standard outputra.
        </para>
        
        <para>
            Fordítás: <command>gcc pagerank.c -lm</command> 
        </para>
        <para>
            Futtatás: <command>./a.out</command>
        </para>
        <para>
            Eredményül a következőt kapjuk:
        </para>
        <figure>
            <title>Pange-Rank eredmény</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/pagerank.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>Page-Rank eredmény</phrase>
                </textobject>
            </mediaobject>
        </figure>
    
    </section>
                                                                                                                                                                                                                                                                                                                                                        

    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Rj8qOjE0gYc">https://youtu.be/Rj8qOjE0gYc</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            A Monty Hall probléma alapja három ajtó, mely mindegyike rejt valamit: két ajtó mögött egy-egy roncs autó van, egy ajtó mögött pedig egy
            vadiúj autó. Ez annyit jelent, hogy két ajtó értéktelen és egy ajtó pedig értékes ajándékot rejt. Azért, hogy könnyebben tudjunk beszélni az egészről, 
            mondjuk azt, hogy két ajtó mögött nincs és egy ajtó alatt pedig van ajándék. A folyamat különböző állomásait a program ismertetése közben prezentálom.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.7/montyhall.r">../Forraskodok/Turing/2.7/montyhall.r</link>   
        </para>
        <programlisting language="c">
<![CDATA[#   An illustration written in R for the Monty Hall Problem 
#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#   https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan
# 

kiserletek_szama=10000000
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)]]>
        </programlisting>
        <para>
            Az első dolgunk hogy megadjuk a kísérletek számát, tehát azt, hogy hanyszor végezzük el a kísérletet, hogy hányszor játszuk el a játékot 
            (ez a mi estetünkben, a mi programunkban 10000000 kört jelent). Minden játékban van harom ajtónk: 1-es, 2-es és 3-as ajtó. A következő sorban a 
            <varname>kiserlet</varname> vektorba berakjuk, hogy az egyes játékokba, melyik ajtó mögé lett betéve az ajándék, tehát hogy melyik ajtó a nyerő.
            (a <command>replace</command> megengedi, hogy a játékok során egy ajtó mögé többször is kerülhessen ajándék). Következik a játékos választásai.
            A <varname>jatekos</varname> vektor feltöltése, ugyanúgy mülködik mint a <varname>kiserlet</varname> esetében, itt a játékos tippjét rögzítjük, 
            hogy szerinte melyik ajtó rejti az ajándékot.
        </para>
        
        <programlisting language="c">
<![CDATA[musorvezeto=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }

    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

}]]>
        </programlisting>
        <para>
            A műsorvezetőnek egy kicsit komplexebb dolga van. Neki most ki kell nyitnia a játékosnakegy ajándékot nem takaró ajtót, de figyelembe kell vennie azt, 
            hogy hova lett elhelyezve az ajándék és hogy mit választott a játékos. A for cilussal végigmegyünk az összes játékon. Az if segítségével döntjül el,
            hogy a műsorvezető melyik ajtót nyissa majd ki. Az if első ágán azt nézzük meg, hogy a játékos ugyanazt az ajtót választotta-e mint amelyikbe az ajándékot elrejtették.
            Ha igen, akkor a <varname>mibol</varname> a másik két ajtószám egyike lesz (az 1, 2 és 3-as ajtók közül kivesszük azt amelyikben az ajándék van). Ha viszont a játékos 
            nem azt az ajtót választja amelik mögött a nyeremény szerepel, akkor jön az else ág, és azt mondjuk, hogy a <varname>mibol</varname> legyen az az ajtó száma, amelyik 
            mögött nem az ajéndék van és amelyiket nem mondtah a játékos (tehát az 1, 2 és 3-as ajtók közül kivesszük azt amelyik a nyereményt rejti és azt amelyiket a jáékos választotta). 
            Miután sikerült eldönteni hogy mi legyen a <varname>mibol</varname> értéke, átadjuk azt a műsorvezetőnek, aki kinyitja azt az ajtót. Igy az ajtó amit mjd kinyit egy üres ajtó lesz.
        </para>

        
        <programlisting language="c">
<![CDATA[
        nemvaltoztatesnyer= which(kiserlet==jatekos)
        valtoztat=vector(length = kiserletek_szama)

        for (i in 1:kiserletek_szama) {

        holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
        valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
        }

        valtoztatesnyer = which(kiserlet==valtoztat)]]>
        </programlisting>
        <para>
            A következőkben a játékosnak el kell döntenie, hogy kiáll az eredeti választása mellet vagy változtat és másik ajtót választ. A <varname>nemvaltoztatesnyer</varname> akkor kap értéket 
            ha a játékos azt az ajtót választotta amelyik az ajándékot rejti, és így nyer majd. Ha viszont nem azt választotta, akkor változtathat a döntésén és ehhez szükségünk lesz egy for ciklusra, 
            amelyik újra végig megy majd az összes játékon. A <varname>holvalt</varname> annak az ajtónak a számát jegyzi meg, amelyik nem is a műsorvezető altal kinyitott és nem is a játékos 
            által választott ajtó volt, a <varname>valtoztat</varname> pedig átveszi tőle ezt az értéket. Aztan megnézi hogy ha az ajándékot rejtő ajtó megegyezik a változtatott értékkel akkor a 
            <varname>valtoztatesnyer</varname> lesz kiiratva nem pedig a <varname>nemvaltoztatesnyer</varname>.
        </para>

        <programlisting language="c">
<![CDATA[
        sprintf("Kiserletek szama: %i", kiserletek_szama)
        length(nemvaltoztatesnyer)
        length(valtoztatesnyer)
        length(nemvaltoztatesnyer)/length(valtoztatesnyer)
        length(nemvaltoztatesnyer)+length(valtoztatesnyer)]]>
        </programlisting>
        <para>
            A program végén már csak egy összegző kiírás van, melyben kiiratjuk, hogy mennyi a jatékok száma (hány kört játszottunk), hányszor volt az, hogy a játékos nem változtatott és nyert illetve 
            hogy változtatással nyert, ezek hányadosa illetve összege.
        </para>
        <para>
            A program futtatása R-ben történik, ehhez szükséges telepíteni azt. A telepítés után belépünk R-be, először a <command>kiserletek_szama=10000000</command>
            sort adjuk be, majd pedig a program többi részét. Az eredményre egy keveset várni kell hiszen ahogy a program elején latjuk 
            a kísérletek száma elég nagy (10000000). Ha ezt az értéket lentebb visszük, akkor a végeredményt is kevesebb idő alatt kapjuk majd meg. Többnyire minden futtatás után más és más eredményt kapunk. 
            Az én esetemben a következő eredmény jön ki:
        </para>
        <figure>
            <title>Monty Hall eredmény</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/monty.png" scale="60" />
                </imageobject>
                <textobject>
                    <phrase>Monty Hall eredmény</phrase>
                </textobject>
            </mediaobject>
        </figure>
        
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Tl7zPmllhY0">https://youtu.be/Tl7zPmllhY0</link> Saját megoldás
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        <para>
            Bepillantás a Brun tételre: A tétel alapja az ikerprímek, tehát azok a prímszámok, melyeknek a különbségük 2. Mivel végtelen sok
            természetes, egész... számunk van, ezért úgyanúgy ahogy az ők darabszámét, úgy az ikerprímekét se tudjuk. De van amit tudunk, mégpedig
            azt, hogy ezek reciprokainak az összege egy számhoz konvergál, ami nemmás mint a Brun-konstans. Ennek értéke se egy pontos szám amit
            tudunk, de az érték megközelítéséhez a következő R programot használjuk, kifejtése lennebb található.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Turing/2.8/brun.r">../Forraskodok/Turing/2.8/brun.r</link>   
        </para>

        <para>
            A természetes számok építőelemei a prímszámok, abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő szám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n!            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primes = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primes=primes(13)
> primes
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primes[2:length(primes)]-primes[1:length(primes)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primes[2:length(primes)]-primes[1:length(primes)-1]
> diff
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[idx = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> idx = which(diff==2)
> idx
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>diff</varname>-ben, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>diff</varname>-ben lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[t1primes = primes[idx]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[t2primes = primes[idx]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/t1primes a t1primes 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t1primes
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/t2primes a t2primes 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t2primes
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/t1primes + 1/t2primes pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>   
               

        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/brun.png" scale="35" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure>                       
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>
    <section>
        <title>Vörös Pipacs Pokol/csiga (folytonos mozgási parancsokkal)</title>
        <para>
            Írj olyan Minecraft MALMÖ python programot, amivel Steve csigavonalban járja be a pályát a folytonos mozgási parancsok felhasználásával.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://www.youtube.com/watch?v=9Pk-qoStK34">Saját megoldás</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Forraskodok/Turing/csiga_folytonos.py">
            	<filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Forraskodok/Turing/csiga_folytonos.py</filename>
            </link>, <link xlink:href="http://hackers.inf.unideb.hu:443/RedFlowerHell/">http://hackers.inf.unideb.hu:443/RedFlowerHell/</link>
        </para>
        <para>
            Steve a négyszögletű pálya mind a négy oldalát bejárja "uthossz" időegységgel, illetve fordul 90 fokot, ha elérte a az oldal szélét. Minden negyedik ilyen bejárás után ugrik egyet a következő szintre, és növeljük az "uthossz" változó értékét, hiszen felfelé haladva nő az út hossza. Ezt a folyamatot Steve a lávában való elégésig ismétli.
        </para>
        <programlisting language="python"><![CDATA[class Steve:
    def __init__(self, agent_host):
        self.agent_host = agent_host
        
        self.nof_red_flower = 0

    def run(self):
        world_state = self.agent_host.getWorldState()
        uthossz = 2
        # Loop until mission ends:
        while world_state.is_mission_running:
            print("--- nb4tf4i arena -----------------------------------\n")
            self.agent_host.sendCommand( "move 1" )
            time.sleep(uthossz)            
            self.agent_host.sendCommand( "turn 1" )
            time.sleep(.5)
            self.agent_host.sendCommand( "turn 0" )
            self.agent_host.sendCommand( "move 1" )
            time.sleep(uthossz)            
            self.agent_host.sendCommand( "turn 1" )
            time.sleep(.5)
            self.agent_host.sendCommand( "turn 0" )
            self.agent_host.sendCommand( "move 1" )
            time.sleep(uthossz)            
            self.agent_host.sendCommand( "turn 1" )
            time.sleep(.5)
            self.agent_host.sendCommand( "turn 0" )
            self.agent_host.sendCommand( "move 1" )
            time.sleep(uthossz)            
            self.agent_host.sendCommand( "jump 1" )
            time.sleep(.5)
            self.agent_host.sendCommand( "jump 0" )
            uthossz = uthossz + 2
            world_state = self.agent_host.getWorldState()
]]></programlisting> 
    </section> 


</chapter>                