<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/lvmi6tyz-nI">https://youtu.be/lvmi6tyz-nI</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/infty-f.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-f.c</filename>
            </link>, 
            <link xlink:href="Turing/infty-w.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-w.c</filename>
            </link>.
        </para>
        <para>
            Számos módon hozhatunk és hozunk létre végtelen ciklusokat. 
            Vannak esetek, amikor ez a célunk, például egy szerverfolyamat fusson folyamatosan és van amikor egy
            bug, mert ott lesz végtelen ciklus, ahol nem akartunk. Saját péláinkban ilyen amikor a PageRank algoritmus
            rázza az 1 liter vizet az internetben, de az iteráció csak nem akar konvergálni...
        </para>                    
        <para>
            Egy mag 100 százalékban:               
        </para>
        <programlisting language="c"><![CDATA[int
main ()
{
  for (;;);

  return 0;
}
]]>
        </programlisting>        
        <para>        
        vagy az olvashatóbb, de a programozók és fordítók (szabványok) között kevésbé hordozható
        </para>
        <programlisting language="c"><![CDATA[int
#include <stdbool.h>
main ()
{
  while(true);

  return 0;
}
]]>
        </programlisting>        
        <para>
            Azért érdemes a <literal>for(;;)</literal> hagyományos formát használni, 
            mert ez minden C szabvánnyal lefordul, másrészt
            a többi programozó azonnal látja, hogy az a végtelen ciklus szándékunk szerint végtelen és nem szoftverhiba. 
            Mert ugye, ha a <literal>while</literal>-al trükközünk egy nem triviális 
            <literal>1</literal> vagy <literal>true</literal> feltétellel, akkor ott egy másik, a forrást
            olvasó programozó nem látja azonnal a szándékunkat.
        </para>            
        <para>
            Egyébként a fordító a <literal>for</literal>-os és 
            <literal>while</literal>-os ciklusból ugyanazt az assembly kódot fordítja:
        </para>            
        <screen><![CDATA[$ gcc -S -o infty-f.S infty-f.c 
$ gcc -S -o infty-w.S infty-w.c 
$ diff infty-w.S infty-f.S 
1c1
< 	.file	"infty-w.c"
---
> 	.file	"infty-f.c"
]]></screen>  
        <para>
            Egy mag 0 százalékban:               
        </para>        
        <programlisting language="c"><![CDATA[#include <unistd.h>
int
main ()
{
  for (;;)
    sleep(1);
    
  return 0;
}
]]>
        </programlisting>        
        <para>
            Minden mag 100 százalékban:               
        </para>

        <programlisting language="c"><![CDATA[#include <omp.h>
int
main ()
{
#pragma omp parallel
{
  for (;;);
}
  return 0;
}
]]>
        </programlisting>        
        <para>
            A <command>gcc infty-f.c -o infty-f -fopenmp</command> parancssorral készítve a futtathatót, majd futtatva,               
            közben egy másik terminálban a <command>top</command> parancsot kiadva tanulmányozzuk, mennyi CPU-t használunk:            
        </para>
        <screen><![CDATA[top - 20:09:06 up  3:35,  1 user,  load average: 5,68, 2,91, 1,38
Tasks: 329 total,   2 running, 256 sleeping,   0 stopped,   1 zombie
%Cpu0 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu1 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu2 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu3 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu4 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu5 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu6 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu7 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
KiB Mem :16373532 total,11701240 free, 2254256 used, 2418036 buff/cache
KiB Swap:16724988 total,16724988 free,       0 used. 13751608 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 5850 batfai    20   0   68360    932    836 R 798,3  0,0   8:14.23 infty-f     
]]></screen>  
                                
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/lvmi6tyz-nI">https://youtu.be/lvmi6tyz-nI</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Alan Turing bebizonyitotta,hogy ilyen programot képtelenség létrehozni,egyszerübb programoknál szemre láthatólag meg lehet állapitani,de komplexebb programoknál lehetetlen,erre bonyorult matematikai számításokkal tudott rájönni a 90-es években.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:  
            <link xlink:href="../../code/Turing/valtozo_erekenek_felcserelese.cpp">
                <filename>code/Turing/valtozo_erekenek_felcserelese.cpp</filename>
            </link>
        </para>
        <para>
            Változókat több féle képpen is fel lehet cserélni.
            Legkönyebb mikor létrehozunk egy változót, amiben belemásoljuk ideiglenesen az értéket, amit felülírunk.
            Majd amivel felülírtuk az felülírjuk az ideiglenes változó értékével.
        </para>
        <para>
            Ha nem akarunk új változó bevezetni, akkor is több módon fel tudjuk cserélni az értékeket.
            Például szorzás-osztással, vagy XOR bit színtű változtatással.
        </para>
        <programlisting language="c">
            <![CDATA[
#include <iostream>

int main()
{

    // Segédváltozóóval
    int f = 3;
    int g = 4;

    std::cout << "f=" << f << std::endl;
    std::cout << "g=" << g << std::endl;

    int tmp = f;
    f = g;
    g =  tmp;

    std::cout << "f=" << f << std::endl;
    std::cout << "g=" << g << std::endl;

    std::cout << std::endl;


    // Segéd változó nélkül
    int a = 10;
    int b = 20;

    std::cout << "a=" << a << std::endl;
    std::cout << "b=" << b << std::endl;

    a = a*b;
    b = a/b;
    a = a/b;

    std::cout << "a=" << a << std::endl;
    std::cout << "b=" << b << std::endl;

    std::cout << std::endl;


    // XOR
    int x = 5;
    int y = 7;

    std::cout << "x=" << x << std::endl;
    std::cout << "y=" << y << std::endl;

    x = x ^ y;
    y = x ^ y;
    x = x ^ y;

    std::cout << "x=" << x << std::endl;
    std::cout << "y=" << y << std::endl;
}

            ]]>
        </programlisting>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  
            <link xlink:href="../../code/Turing/labda.c">
                <filename>code/Turing/labda.c</filename>
            </link>
        </para>
        <para>
            Ezt a feladatot egy 2d-s játék motorjához tudom hasonlítáni. 
        </para>
        <para>
            Egy kordináta rendszert kell elképzeni, ahol a labda egy pont.
            Ez a pontot kell mozgatni egy "irány vektorral" (ez nem a matematikai irány vektor vektor). A vektornak 2d minenziós, van egy 
            x és egy y offset. Ezeket at offseteket minden iterációban hozzáadjuk a labda kordinátáihoz. Az offsetek csak akkor változnak, ha 
            elérik a megadott "screen" (terminál ablak) oldalait (szélső értékeit), ekkor az offsetek -1-szeresére változnak, vagyis megfordúlnak.
        </para>
    
        <programlisting language="c">
        <![CDATA[
#include <stdio.h>
#include <curses.h>
#include <unistd.h>
#include <stdlib.h>


int main (void)
{
    WINDOW* window;
    window = initscr ();

    int xdesc=0,ydesc=0, xasc=0,yasc=0;
    int maxX;
    int maxY;

    for (;;) {

        getmaxyx ( window, maxY , maxX );
        maxY=maxY*2;
        maxX=maxX*2;
        refresh();
        clear();
        usleep (80000);

        xdesc = (xdesc-1) % maxX;
        xasc = (xasc+1) % maxX;
        ydesc = (ydesc-1) % maxY;
        yasc = (yasc+1) % maxY;

        mvprintw(abs((ydesc + (maxY-yasc))/2),abs((xdesc+(maxX-xasc))/2),"O");
    }
}

        ]]>
        </programlisting>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>, 
            <link xlink:href="https://youtu.be/KRZlt1ZJ3qk">https://youtu.be/KRZlt1ZJ3qk</link>, 
            <link xlink:href=""></link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/bogomips.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/bogomips.c</filename>
            </link>
        </para>
        <para>
            A szóhossz megadja hogy az adott int-et a gép hány bit-en tárolja.
            A "word" változó értéke 1. vagyis 2^0-on (00000001) ez az egy bitet a shifteljük (mozgatjuk) balra.
            Így a word érteke 2^1 vagyis 2 (00000010). Ezzel párhuzamosan növelünk egy másik értéket is, hogy a végén megtudjuk hányszor
            shifteltünk. Addig tudjuk tólni ezt egy bitet, ahány bit-en tárolja a gép az int-et, vagyis a elérjük az utolsó 2 hatványát,
            akkor kifutunk a helyből és az az 1 bit már máshol lesz (nem lesz ott, eltűnik, minden bit 0 lesz) vagyis a word értéke 0 lesz, hamis.
        </para>
        <programlisting language="c">
        <![CDATA[
#include<stdio.h>

int main(){
    unsigned long long int wordLength = 0, word = 1;

    while(word <<= 1){
        wordLength++;
    }
    
    wordLength++;
    printf("The word length on this PC is %llu bits\n", wordLength);
    return 0;
}
        ]]>
        </programlisting>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://www.youtube.com/watch?v=5wRFa8l35QI">https://www.youtube.com/watch?v=5wRFa8l35QI</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="../../code/Turing/page_rank.c">
                <filename>code/Turing/page_rank.c</filename>
            </link>
            
        </para>
        <para>
            A page rank algoritmust a Google fejlesztette ki, hogy kategórizálni és értékelni tudja a weblapokat.
            Az alap gondolat az, hogy egy oldal annál értékesebb, minél több értékes oldal mutat rá.
        </para>


        <programlisting language="c">
        <![CDATA[
#include <stdio.h>
#include <math.h>

void kiir(double tomb[], int db)
{
    for(int i=0; i<db; ++i){
        printf("%f\n", tomb[i]);
    }
}

double tavolsag(double PR[], double PRv[], int n)
{
    double osszeg = 0;

    for (int i = 0; i < n; ++i)
    {
        osszeg += (PRv[i] - PR[i]) * (PRv[i] - PR[i]);
    }

    return sqrt(osszeg);
}

int main(void)
{
    double L[4][4] = {
        {0.0, 0.0, 1.0 / 3.0, 0.0},
        {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
        {0.0, 1.0 / 2.0, 0.0, 0.0},
        {0.0, 0.0, 1.0 / 3.0, 0.0}
    };

    double PR[4] = {0.0, 0.0, 0.0, 0.0};
    double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

    int i,j;

    for(;;){
        for(i=0; i<4;++i){
            PR[i] = 0.0;
            for(j=0; j<4; ++j){
                PR[i] += L[i][j] * PRv[j];
            }
        }

        if(tavolsag(PR, PRv, 4) < 0.0000000001)
            break;

        for(i=0; i<4; ++i){
            PRv[i] = PR[i];
        }
    }

    kiir(PR, 4);
    return 0;
}
        ]]>
    </programlisting>
    </section>
                                                                                                                                                                                                                                                                                                                                                        
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
                A Monty Hall probléma egy régi tv műsor alapján létrejött teória. A műsorban a játékos 3 ajtó közül választhatott amelyek egyike mögött ott volt
                a nagy nyeremény. Eddig a középiskolás valószínűség számítás szerint mindenki úgy gondolja, hogy a nyerési esély 1/3 (33.33%) és ekkor még mindenkinek igaza lenne.
            </para>

            <para>
                A játék úgy zajlott, hogy a játékos választott 1 ajtót a 3 közül. Utánna Monty (a műsorvezető, aki tudta, hogy minden ajtó mögött mi van) választott egy olyan
                ajtót ami mögött biztosan nincs semmi, aztán megkérdezte a játákost, hogy el akarja e cserélni a választott ajtót a másik ajtóval ami még zárva volt.
                A játékos megtarthatta a választott ajtót vagy átmehetett a másikhoz. Ebben az esetben, HOSSZÚTÁVON mindig az nyert többet, aki a másik ajtót választotta.
            </para>

            <para>
                Miért? Azért mert az elején minden ajtó nyerési lehetősége 1/3 (33.33%). Amikor kiválasztunk egy ajtót akkor nálunk van egy ajtó 1/3 nyerési lehetőséggel, 
                szemben velünk meg 2 1/3 ajtó vagyik az esélyek 1/3(33.33%) a 2/3(66.66%) ellen (2 ajtó formájában). Mikor Monty kinyit egy ajtót ami mögött nincs semmi,
                akkor annak az ajtónak a nyerési esélye átszáll az utolsó ajtóra, vagyik egy ajtóba sűrűsül 2 ajtó nyerési esélye, így az az ajtó értéke 2/3(66.66%) lesz.
                Így jogosan hangzik az, hogy jobb ha a másik ajtót választjuk aminek nagyobb az esélye. Fontos megjegyzés, hogy ez a technika nem garantálja a nyerést.
                Most tegyük fel, hogy van 100 (vagy több) ajtónk. Ha választunk egyet, akkor a nyerési esélye az ajtónak 1/100(1%). Utánna Monty kinyit nekünk 98 olyan
                ajtót ami mögött nics semmi, akkor az utolsó ajtónak a nyerési esélye 1/99(99%) (e teória alapján).
            </para>
        <programlisting language="R">
        <![CDATA[
kiserletek_szama=100000
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)
musorvezeto=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }

    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

}

nemvaltoztatesnyer= which(kiserlet==jatekos)
valtoztat=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
}

valtoztatesnyer = which(kiserlet==valtoztat)


sprintf("Kiserletek szama: %i", kiserletek_szama)
length(nemvaltoztatesnyer)
length(valtoztatesnyer)
length(nemvaltoztatesnyer)/length(valtoztatesnyer)
length(nemvaltoztatesnyer)+length(valtoztatesnyer)
]]>
        </programlisting>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>

        <para>
            A természetes számok építőelemei a prímszámok. Abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő azám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n.            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primes = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primes=primes(13)
> primes
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primes[2:length(primes)]-primes[1:length(primes)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primes[2:length(primes)]-primes[1:length(primes)-1]
> diff
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[idx = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> idx = which(diff==2)
> idx
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>diff</varname>-ben, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>diff</varname>-ben lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[t1primes = primes[idx]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[t2primes = primes[idx]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/t1primes a t1primes 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t1primes
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/t2primes a t2primes 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t2primes
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/t1primes + 1/t2primes pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>          
        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>

</chapter>                
