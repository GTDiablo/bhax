<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>
            <type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c">
                <filename>nbatfai/bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Caesar/4.1/tm.c">../Forraskodok/Caesar/4.1/tm.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int nr = 5;
    double **tm;
    
    printf("%p\n", &tm);

    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }
    printf("%p\n", tm); ]]>
        </programlisting>
        <para>
            A program első soraiban létrehozunk egy <varname>nr</varname> változót, melynek értéket is adunk: 5. Ez az ötös 
            szám arra utal, hogy a program futtatását követően kiírt alsó háromszögmátrix (az eslő sorban eg elem lesz, a 
            másodikban kettő, stb.) 5 soros lesz. A <command>double **tm</command> végrehajtódásakor deklaráljuk a 
            <varname>tm</varname> nevű változót, a *-al jelezvén hogy ez egy pointer, egy mutató, és a program le is foglal neki monjuk 8 bájtnyi 
            tárhelyet. Ezek után ki is íratjuk a tm memóriacímét. A következőkben szerepel a <function>malloc</function> függvény, amelyik (mint a <command>man 3 malloc</command> 
            paracs lekérése után is kiderül), helyet foglal a memóriában és egy <type>void *</type> pointert ad vissza, ami bármire mutathat, 
            majd mi megadunk meg egy típust, hogy arra mutasson amire mi akarjuk. A <function>malloc</function> paraméterül megkapja hogy mekkora 
            területet kell lefoglajon, most egy sizeof paramétert kap, ami a <type>double *</type> tipus helyigényét adja vissza 
            (tehát nr * sizeof (<type>double *</type>) = 5*8 = 40 bájtot kell lefoglaljon a tm számára). Az if-el at ellenőrizzük, 
            hogy a <function>malloc</function> sikeresen lefoglalta-e a helyet a memóriában és hogy sikeresen vissza adta-e 
            a <type>void *</type> mutatót. Ha ez nem sikerült, akkor egyenlő a NULL-al, vagyis nem mutat sehová és kilép a programból 
            (ez akkor szokott bekövetkezni amikor nincs elegendő tárhelyünk és nem sikerül a memóriafoglalás).  
            Tegyük fel, hogy nekünk ez most sikerült (ezért ki is íratjuk a tm <function>malloc</function> által visszaadott címét), 
            ezért menjünk is tovább a program többi részére (a lefoglalt területet az ábrán a középső sor jelöli).
        </para>

        <programlisting language="c">
<![CDATA[for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }
    printf("%p\n", tm[0]); ]]>
        </programlisting>
        <para>
            A következőkben egy for ciklussal úgymond végigmegyünk az 5 soron és mindengyik sorban úrja lesz egy 
            memóriafoglalás. Nézzük pédának hogy mit fog csinálni abban az esetben amikor az <varname>i</varname>=3: 
            mint mondottam a <function>malloc</function> egy  <type>void *</type> pointert ad vissza, de mi kikötjük hogy ez nekünk most <type>double *</type> legyen.
            A <function>malloc</function> a tm[2]-nek most (2+1 * 8) bájtot foglal, vagyis a harmadik sorban három 8 
            bájtnyi helyet foglal le, a harmadik <type>double *</type> egy olyan sorra mutasson ahol három doublenek van lefoglalva hely
            (az ábrán ezt az utolsó sor urolsó három cellára jelöli). Ez az egész egy if feltételeként 
            szerepel, melyben ismét ellenőrzi hogy sikeres volt-e a pointer létrehozása és a hely lefogalása, ha nem akkor egyenlő a NULL-lal 
            és megáll a program. De tegyük fel újra, hogy sikerrel jártunk, ezért kiíratjuk a tm[0], az első sor memóriacímét, 
            majd megyünk tovább.
        </para>
        
        <programlisting language="c">
<![CDATA[for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }]]>
        </programlisting>
        <para>
            Egy következő for ciklussal megszerkesztjük az alsó háromszögmátrixot (ehhez két for ciklus szükséges, 
            mivel igy tudjuk meghatározni az elem sorát és oszlopát), azáltal, hogy az egyes, sor- és 
            oszlopindexekkel jelölt elemek értéket kapnak (az <varname>i</varname> 
            <varname>nr</varname>-ig, a 
            <varname>j</varname> pedig <varname>i</varname>-ig megy, így biztosítva az alsó háromszögmátrix alakot). 
            Lássuk, hogy hogy mülködik az értékadás, amikor az i=1 és j=0: ekkor a második sor első elemének adunk 
            egy (1*2/2+0=) 1-es (double) értéket. Az értékadások végeztével, újabb for ciklusok segítségével kiíratjuk 
            a kapott alsó háromszögmátrixot.
        </para>
        
        <programlisting language="c">
<![CDATA[tm[3][0] = 42.0;
    (*(tm + 3))[1] = 43.0;	// mi van, ha itt hiányzik a külső ()
    *(tm[3] + 2) = 44.0;
    *(*(tm + 3) + 3) = 45.0;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }]]>
        </programlisting>
        <para>
            Ebben a részben az első négy sor különböző leírások arra, hogy a negyedik sorban lévő négy értéket 
            hogy változtassuk meg, tehát példa arra, hogy hogyan lehet hivatkozni a különböző elemekre ahhoz 
            hogy valamit tudjunk velük csinálni (ezesetben az értékmódosítás művelet végrehajtását). Az értékek 
            megváltoztatása után újra kiíratjuk az alsó háromszögmátrixunkat.
        </para>
        <programlisting language="c">
<![CDATA[
    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);

    return 0;
}]]>
        </programlisting>
        <para>
            A program utolsó részében a <function>free</function> függvény segítségével felszabadítjuk az egyes sorokban
            illetve az egesz tm által foglalt memóriát.
        </para>
        <para>
            Fordítás: <command>gcc tm.c -o tm</command> 
        </para>
        <para>
            Futtatás: <command>./tm</command>
        </para>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="105" />
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        
        <figure>
            <title>A program által kiírt eredmény</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/tm.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A program által kiírt eredmény</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
                  
    </section>  
          
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Caesar/4.2/e.c">../Forraskodok/Caesar/4.2/e.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[﻿#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 256


int
main (int argc, char **argv)
{

  char kulcs[MAX_KULCS];
  char buffer[BUFFER_MERET];

  int kulcs_index = 0;
  int olvasott_bajtok = 0;

  int kulcs_meret = strlen (argv[1]);
  strncpy (kulcs, argv[1], MAX_KULCS);

  while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
    {

      for (int i = 0; i < olvasott_bajtok; ++i)
	{

	  buffer[i] = buffer[i] ^ kulcs[kulcs_index];
	  kulcs_index = (kulcs_index + 1) % kulcs_meret;

	}

      write (1, buffer, olvasott_bajtok);

    }
}]]> 
        </programlisting>
        <para>
            Egy <command>tiszta.szoveg</command> nevű féjl létrehozása, egy szöveg beletétele.
        </para>
        <para>
            Fordítás: <command>gcc e.c -o e -std=c99</command> 
        </para>
        <para>
            Futtatás: <command>./e kulcs &lt;tiszta.szoveg &gt;titkos.szoveg</command> (a kulcs bármi lehet)
        </para>
        <para>
            Dekódolás: <command>./e kulcs &lt;titkos.szoveg</command> (a kulcs meg kell egyezzen a fent használt kulccsal)
        </para>
        <para>
            Az exor titkosító, mint ahogy a neve is mondja, exor müvelet segítségével szöveget titkosít a számunkra. 
            A bevitt, titkosítandó szöveg emberi fogyasztásra alkalmas, de a titkosított viszont már annál kevésbé.
            A dekósolásnál lévő parncs segítségével képesek vagyunk a titkos szövegből visszaadni az eredeti szöveget.
            A program elején deklarálunk egy kulcsot, egy buffert (ami az olvasott bájtok egyes bájtjait veszi fel), 
            majd bekérjük az olvasott bájtokat (a mi esetünkben a tiszta.szoveg nevű fájlból).
            A program egyessével végigmegy a beolvasott bájtokon, majd azokat össze xorozza az adott kulcs indexel ami 
            a kulcsban következik, majd a kulcson belül is továbblép a következő karakterre (ha a kulcs 4 karakter akkor 
            sorban mindig azon a 4 karakteren megy végig). Ezért játszik fontos szerepet a kulcs, mivel anélkül nem  
            tudjuk feltörni a titkosított szöveget.
        </para>        
    </section>
           
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Caesar/4.3/exortitkosito.java">../Forraskodok/Caesar/4.3/exortitkosito.java</link>   
        </para>
        <para>
            A következő java program egy titkosító és egyben egy törő program is, mivel ha újra végrehajtjuk a titkosítást 
            akkor visszakapjuk az eredeti szöveget. Ezt az müveletet az exortitkosito osztályban végezzük el.
        </para>
        <programlisting language="c">
<![CDATA[public class exortitkosito {
    
    public exortitkosito(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new exortitkosito(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}]]> 
        </programlisting>
        <para>
            Mint mindegyik titkosító/törő programban van egy ciklus melyik apránként olvassa a bemenetet, ebben az esetben 
            egy while ciklus, mely tömbönként olvas be. A titkosítás folyamata teljesen az mint az előző C exor titkosító 
            programban. A <varname>kulcsIndex</varname>-et ráállítjuk a kulcs adott karakterére ami következik, majd ezen és 
            a buffer által beolvasott karakteren elvégezzük a kizáró vagy műveletet. Az eredmény a buffer tömbbe kerül, a program 
            végén ezt íratjuk majd ki.
        </para>
        <para>
            A program futtatása (titkosítandó szöveg bekérése, titkosítása és visszaváltoztatása):
        </para>
        <para> 
            <command>javac exortitkosito.java</command> (létrejön az exortitkosito.class fájl)
        </para> 
        <para>
            <command>java exortitkosito alma &gt;  titkositott.txt</command> (a titkosítandó szöveg bevitele)
        </para>
        <para>
            <command>more titkositott.txt</command> (kiíratódik a titkosított szöveg)
        </para>  
        <para>
            <command>java exortitkosito alma &lt;  titkositott.txt</command> (dekódoljuk a titkosított szöveget, visszakapva az eredetit)
        </para> 
        
        <figure>
            <title>A program mülködése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/exortitkositojava.png" scale="65" />
                </imageobject>
                <textobject>
                    <phrase>A program mülködése</phrase>
                </textobject>
            </mediaobject>
        </figure>             
    </section>  
          
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Caesar/4.4/t.c">../Forraskodok/Caesar/4.4/t.c</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
  int sz = 0;
  for (int i = 0; i < titkos_meret; ++i)
    if (titkos[i] == ' ')
      ++sz;

  return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
  // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
  // illetve az átlagos szóhossz vizsgálatával csökkentjük a
  // potenciális töréseket

  double szohossz = atlagos_szohossz (titkos, titkos_meret);

  return szohossz > 6.0 && szohossz < 9.0
    && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
    && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}]]> 
        </programlisting>
        <para>
            A program elején lesz három nagyon fontos és beszédes definíciónk: A titkos szöveg maximum mérete, a beolvasott 
            buffer mérete és a kulcs mérete, ami, az előző programmal szemben, itt már nem lehet akármi, hanem ezt a program 
            végén fogjuk ezt iterálni, most annyit tudunk hogy 8 hosszúságú. A <function>atlag_szohossz</function> függvénynek 
            is beszédes neve van, ezt a függvényt a következő függvényben már használjuk is ami nemmás mint a <function>tiszta_lehet</function>.
            Ez a függvény úgymond megtippeli, hogy a szöveg amit kapott az megfelel-e a magyar nyelv néhány iratlan szabályának, 
            mint például az hogy tartalmazza-e a leggyakoribb magyar szavakat (hogy, nem, az, ha), mivel ritka az az értelmes 
            magyar nyelven íródott szöveg amikben ezek egyike legalább nem fordul elő.
        </para>
        
        <programlisting language="c">
<![CDATA[void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

  int kulcs_index = 0;

  for (int i = 0; i < titkos_meret; ++i)
    {

      titkos[i] = titkos[i] ^ kulcs[kulcs_index];
      kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}]]> 
        </programlisting>
        <para>
            A követező függvény az ami a tiszta szövegből titkosat csinál az exor művelet segítségével, ugyanazzal a 
            módszerrel mint az Exor titkosító programban. A program egyessével végigmegy a beolvasott bájtokon, majd 
            azokat össze xorozza az adott kulcs indexel ami a kulcsban következik, majd a kulcson belül is továbblép 
            a következő karakterre. 
        </para>
        
        <programlisting language="c">
<![CDATA[int
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
	    int titkos_meret)
{

  exor (kulcs, kulcs_meret, titkos, titkos_meret);

  return tiszta_lehet (titkos, titkos_meret);

}]]> 
        </programlisting>
        <para>
            Nagy meglepődésünkre a törő függvény nem rendelkezik külön erre a célra kifejlesztett algoritmussal, hanem 
            felhasználja az előbb bemutatott <function>exor</function> függvényt, mivel ha valamit exorozunk egy adott 
            kulccsal, majd ugyanazzal a kulccsal újra megcsináljuk az exor műveletet akkor visszakapjuk az eredeti szöveget.
            Az exor eme tulajdonságát kihasználva az <function>exor_toro</function> elvégzi a titkos szöveg visszaváltoztatását
        </para>
        
        <programlisting language="c">
<![CDATA[int
main (void)
{

  char kulcs[KULCS_MERET];
  char titkos[MAX_TITKOS];
  char *p = titkos;
  int olvasott_bajtok;

  // titkos fajt berantasa
  while ((olvasott_bajtok =
	  read (0, (void *) p,
		(p - titkos + OLVASAS_BUFFER <
		 MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
    p += olvasott_bajtok;

  // maradek hely nullazasa a titkos bufferben  
  for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
    titkos[p - titkos + i] = '\0';

  // osszes kulcs eloallitasa
  for (int ii = '0'; ii <= '9'; ++ii)
    for (int ji = '0'; ji <= '9'; ++ji)
      for (int ki = '0'; ki <= '9'; ++ki)
	for (int li = '0'; li <= '9'; ++li)
	  for (int mi = '0'; mi <= '9'; ++mi)
	    for (int ni = '0'; ni <= '9'; ++ni)
	      for (int oi = '0'; oi <= '9'; ++oi)
		for (int pi = '0'; pi <= '9'; ++pi)
		  {
		    kulcs[0] = ii;
		    kulcs[1] = ji;
		    kulcs[2] = ki;
		    kulcs[3] = li;
		    kulcs[4] = mi;
		    kulcs[5] = ni;
		    kulcs[6] = oi;
		    kulcs[7] = pi;

		    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
		      printf
			("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
			 ii, ji, ki, li, mi, ni, oi, pi, titkos);

		    // ujra EXOR-ozunk, igy nem kell egy masodik buffer  
		    exor (kulcs, KULCS_MERET, titkos, p - titkos);
		  }

  return 0;
}]]> 
        </programlisting>
        <para>
            Következik a main, a főprogram ahol az előbbieket felhasználjuk. Beolvassuk a titkos szöveget, és itt látszik 
            egy nagy különbség az előző C exor titkosító programmal, ez nem foglal le külön területet a tiszta illetve a titkos 
            szövegnek, tehát a kódolt és a dekódolt szövegnek. A titkos szöveg bekérése után, megnézi hogy a kisebb e a mérete 
            mint amennyit az elején lefoglalt neki a MAX_TITKOS-ba, ha igen akkor a maradék helyet kinullázza. Ezután előállítja 
            a kulcsokat majd jöhet az exorozás, tehát a törés és a titkosítás müvelete.
        </para>
        
        <para>
            Fordítás: <command>gcc t.c -o t</command> 
        </para>
        <para>
            Futtatás: <command>./t</command>
        </para>          
    </section>   
         
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>

        <para>
            A neurális hálók irányított (bemeneti és kimeneti) kapcsolatokkal összekötött egységekből állnak. Az a(0-j) 
            az inputról (más idegsejtekből) bejövő axonok, kapcsolatok (az "a"-k). Ezekből az "a"-kból rendre csinál egy eltolási súlyt, 
            a W-t, ami meghatározza a kapcsolat erősségét és előjelét, majd ezt a megfelelő "a"-val összeszummázza, tehát
            i a bemenetek egy súlyozott összege lesz. A kapott összegre alkalmazunk egy aktivációs függvényt (g), ezáltal 
            megkapva a kimeneti kapcsolatot.
        </para>
        <figure>
            <title>A neurális háló illusztrálása</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuralishalo.png" scale="70" />
                </imageobject>
                <textobject>
                    <phrase>A neurális háló illusztrálása</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Forraskodok/Caesar/4.5/neutoae.r">../Forraskodok/Caesar/4.5/neutoae.r</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# https://youtu.be/Koyw6IH5ScQ

library(neuralnet)

a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)

or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)

compute(nn.or, or.data[,1:2])]]>
        </programlisting>
        <para>
            Az a1 és az a2-ben megadtunk 0-k és 1-sek sorozatát majd az OR-ba az "a1 or a2" müvelet eredményét, majd ebből 
            adatot csinálunk az <varname>or.data</varname> változóba. Az <varname>nn.or</varname> változóba használjuk a 
            <function>neuralnet</function> függvényt, amely kiszámolja nekünk a neutrális hálót. Átadjuk neki az adatokat 
            (amit az előbb előállítottunk az a1, a2 és az OR-ból), tehát megtanítjuk neki ezt az OR müveletet, majd saját 
            magát továbbfejlesztve beállítja a súlyokat úgy hogy megtanulja a dolgok menetét. Fontos hogy a <function>neuralnet</function> függvényt nem a logikai 
            műveletet végzi el, hanem tényleges tanulás után probálja megmondani az eredményt nekünk.
            A <function>plot</function> függvénnyel kirajzoltatjuk az első 
            csatolt képen látható ábrát, ami illusztrálja a számitásokat. Itt látható az ismétlések száma, hogy hányszor végezte 
            a müveletet (steps) és hogy ezekből hányszor kapott rossz eredményt (errors, nagyon kicsi). A <command>compute</command> paranccsal 
            beadjuk neki az adatokat és számítésra utasítjuk a függvényünket, tehát kikérdezzük tőle azt amit megtanítottunk 
            neki az elején. És ahogy a második kép mutatja ügyesen megtanulta és vissza is adta a helyes eredményeket. 
        </para>
        <figure>
            <title>Neurális OR kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuor.png" scale="55" />
                </imageobject>
                <textobject>
                    <phrase>Neurális OR kép</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <figure>
            <title>Neurális OR eredmény</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuron1.png" scale="45" />
                </imageobject>
                <textobject>
                    <phrase>Neurális OR eredmény</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        
        <programlisting language="c">
<![CDATA[a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])]]>
        </programlisting>
        <para>
            A küvetkező rész annyiban különbözik az előző résztől, hogy most az OR müvelet mellett az AND müveletet is 
            megtanítjuk a programnak, majd mind a kettőt kiíratjuk. Mind a két képen lázhatjuk, hogy az OR mellé társul 
            az AND is (egy hálózatban lehet két kimenet is). A második kép bizonyítja, hogy az AND müveletet is tokéletesen elsajátította.
        </para>
        <figure>
            <title>Neurális AND kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuand.png" scale="55" />
                </imageobject>
                <textobject>
                    <phrase>Neurális AND kép</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <figure>
            <title>Neurális AND eredmény</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuron1.png" scale="45" />
                </imageobject>
                <textobject>
                    <phrase>Neurális AND eredmény</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        
        <programlisting language="c">
<![CDATA[a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])]]>
        </programlisting>
        <para>
            A harmadik részben kipróbaljuk, hogy a program képes elsajátítani-e az exor müveletet is. Ugyanazzokkal a lépésekkel 
            tanítjuk meg neki a dolgokat. A futtatás után viszont nemvárt eredményt kapunk: a program helytelen eredményt adott 
            vissza. Ez volt az a nagy katasztrófális hiba ami miatt sok időre le is fordultak a neurális háló tanulmányozásától. 
            Az első képen látszik hogy a hiba az előzőekhez képest elég nagy. A második képen pedig az tűnik fel hogy a helyes 
            eredmények helyett (0 vagy 1) mindeütt egy 0.5 közeli eredményt kapunk, nem tudja eldönteni hogy melyik a jó, 50-50% 
            esélyt ad mindkettőnek.
        </para>
        <figure>
            <title>Neurális EXOR kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuexor.png" scale="55" />
                </imageobject>
                <textobject>
                    <phrase>Neurális EXOR kép</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <figure>
            <title>Neurális EXOR eredmény</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neuron1.png" scale="45" />
                </imageobject>
                <textobject>
                    <phrase>Neurális EXOR eredmény</phrase>
                </textobject>
            </mediaobject>
        </figure> 

        <programlisting language="c">
<![CDATA[a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])]]>
        </programlisting>
        <para>
            A negyedik példa az exor javított változata. A kettő közti különbség a rejtett neutronok számánál van: az előző 
            feladatban ez 0 volt (hidden=0), most pedig egyből három értéket kap egy lista által, többrétegű lesz (hidden=c(6, 4, 6)). Mint látjuk, az eredményeknél 
            itt már sokkal több értéket ír ki, de most mind jó értékeket, a képen pedig szintúgy látható a bal szélen az a1 és az a2, majd a az első rejtett 
            (6 neuron), a második (4 neuron) és a harmadik rejtett réteg (6 neuron).
        </para>
        <figure>
            <title>Neurális EXOR kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/neu_exor.png" scale="55" />
                </imageobject>
                <textobject>
                    <phrase>Neurális EXOR kép</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        
                  
    </section> 
           
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
        <para>
            Ez a program sokban kötődik az előző programhoz, mivel ebben is egyfajta tanítási módszert mutatunk be. 
            A perceptronok, másnéven egyrétegű előrecsatolt neurális hálók, olyan hálók amelyekben az összes bemenet 
            közvetlenül a kimenetekre kapcsolódik (minden súly csak egy kimenetre van hatással). A perceptronok az alap 
            logikai műveleteken túl képesek a bonyolultabbakat is bemutatni röviden. A hiba-visszaterjesztést többrétegű perceptron 
            (MLP) esetén tudjuk csak alkalmazni. A többrétegű perceptron rétegekbe szervezett neuronokból áll. A rétegek mennyisége
            többnyire változó, minden esetben van egy bemeneti-, egy kimeneti- és a kettő között egy vagy több rejtett réteg
            A következő programok együttese olyan algoritmus, amelyik megtanítja a gépnek a bináris osztályozást.
        </para>
        <para> 
            A forráskód megtalálható a következő linken: <link xlink:href="Forraskodok/Caesar/4.6/mandelpng.cpp">../Forraskodok/Caesar/4.6/mandelpng.cpp</link>   
        </para> 
        <para>
            A program itt nem kap nagy, részletező bemutatást, mivel a következő fejezetben erről illetve csak ilyenekről lesz majd szó.
        </para>
        <para>
            Fordítás: <command>g++ mandelpng.cpp -o mandel -lpng</command> 
        </para>
        <para>
            Futtatás: <command>./mandel mandel_perceptron.png</command>
        </para> 
        <para>
            A kép megtekintése: <command>eog mandel_perceptron.png</command>
        </para>
        <figure>
            <title>Mandelbrot kép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel_perceptron.png" scale="45" />
                </imageobject>
                <textobject>
                    <phrase>Mandelbrot kép</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        
        <para>
            Szükségünk van még a következő programra, amelyik megtalálható a következő linken: <link xlink:href="Forraskodok/Caesar/4.6/perceptron.hpp">../Forraskodok/Caesar/4.6/perceptron.hpp</link> 
        </para>
        
        <para> 
            A forráskód megtalálható a következő linken: <link xlink:href="Forraskodok/Caesar/4.6/main.cpp">../Forraskodok/Caesar/4.6/main.cpp</link>   
        </para> 
        <programlisting language="c">
<![CDATA[#include <iostream>
#include "perceptron.hpp"
#include "png++/png.hpp"

int main (int argc, char **argv)
{
    png::image <png::rgb_pixel> png_image (argv[1]);

    int size = png_image.get_width() * png_image.get_height();
    
    Perceptron* p = new Perceptron (3, size, 256, 1);
    
    double* image = new double[size];
    
    for (int i = 0; i<png_image.get_width(); ++i)
        for (int j = 0; j<png_image.get_height(); ++j)
            image[i*png_image.get_width() + j] = png_image[i][j].red;
    
    double value = (*p) (image);
    
    std::cout << value << std::endl;
    
    delete p;
    delete [] image;   
}]]>
        </programlisting>
        <para>
            A fentebb említett perceptron.cpp programot a mainben meg is hívjuk header fájlként, átláthatóbbá téve a főprogramot. A fő számítások viszont a perceptron.hpp-ben
            vannak, a mainben az ott deklarált Perceptron osztályt hívjuk segítségül meg az eredmény kiszámolásának céljából.
            A mainben a png.hpp header fájl segítségével létrehozunk egy új png kiterjesztésű képet, úgyanolyan szélességgel és magasséggal 
            mint a mandelbrotos kép volt. A két egymásbaágyazódó for ciklus segítségével végigmegyünk a kép minden pixelén és az előzőekben 
            lementett mandel_perceptron.png pixeleinek piros (red) komponenseit rámásoljuk a most létrehozott kép pixeleire. A program végén 
            pedig kiíratjuk ezt a percceptron értéket a <varname>value</varname> változó segítségével.
        </para>
        
        <para>
            Fordítás: <command>g++ perceptron.hpp main.cpp -o main -lpng -std=c++11</command> 
        </para>
        <para>
            Futtatás: <command>./main mandel_perceptron.png </command>
        </para>  
        <para>
            A kiadott eredmény: <command>0.731044</command>
        </para> 

    </section>   
     <section>
        <title>Vörös Pipacs Pokol/írd ki, mit lát Steve</title>
        <para>
            Írj olyan Minecraft MALMÖ python programot, ami kiírja, hogy Steve milyen blokkokat érzékel maga előtt!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/7_KLcSkaOME">Megoldó videó</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Forraskodok/Caesar/mitlatsteve.py">
            	<filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Forraskodok/Caesar/mitlatsteve.py</filename>
            </link>, <link xlink:href="http://hackers.inf.unideb.hu:443/RedFlowerHell/">http://hackers.inf.unideb.hu:443/RedFlowerHell/</link>
        </para>
        <para>
            A belinkelt forrás alapján "felokosítjuk" az előző fejezetben megírt kódunkat, így Steve mozgás közben érzékeli az őt körülvevő blokkokat. Ezek is mind kiírathatók, de az alábbi kódban ki vannak kommentelve, így csak a <literal>LineOfSight</literal> látható, ami mindig azt a blokkot jelenti, amelyikre Steve néz. Ez fog nekünk segíteni abban, hogy bizonyos dolgok láttán különböző cselekvéseket rendelhessünk a karakterhez.
        </para>
        <programlisting language="python"><![CDATA[class Steve:
    def __init__(self, agent_host):
        self.agent_host = agent_host
        
        self.nof_red_flower = 0

    def run(self):
        world_state = self.agent_host.getWorldState()
        uthossz = 9
        szamlalo = 0
        self.agent_host.sendCommand( "look 1" )
        while world_state.is_mission_running:
            for i in range(uthossz):
                self.agent_host.sendCommand( "move 1" )
                time.sleep(.23)
                world_state = self.agent_host.getWorldState()

                if world_state.number_of_observations_since_last_state != 0:
                
                    sensations = world_state.observations[-1].text
                    #print("    sensations: ", sensations)                
                    observations = json.loads(sensations)
                    nbr3x3x3 = observations.get("nbr3x3", 0)
                    #print("    3x3x3 neighborhood of Steve: ", nbr3x3x3)
                    
                    if "Yaw" in observations:
                        self.yaw = int(observations["Yaw"])
                    if "Pitch" in observations:
                        self.pitch = int(observations["Pitch"])
                    if "XPos" in observations:
                        self.x = int(observations["XPos"])
                    if "ZPos" in observations:
                        self.z = int(observations["ZPos"])        
                    if "YPos" in observations:
                        self.y = int(observations["YPos"])  
                    
                    #print("    Steve's Coords: ", self.x, self.y, self.z)        
                    #print("    Steve's Yaw: ", self.yaw)        
                    #print("    Steve's Pitch: ", self.pitch)
                    
                    if "LineOfSight" in observations:
                        lineOfSight = observations["LineOfSight"]
                        self.lookingat = lineOfSight["type"]
                        print("    Steve's <): ", self.lookingat)

            szamlalo = szamlalo + 1
            if szamlalo % 4 == 0:
                self.agent_host.sendCommand( "jumpmove 1" )
                time.sleep(.5)
                self.agent_host.sendCommand( "move 1" )
                time.sleep(.5)
                self.agent_host.sendCommand( "turn -1" )
                time.sleep(.5)
                uthossz = uthossz + 4
            else:
                self.agent_host.sendCommand( "turn -1" )
                time.sleep(.5)
            world_state = self.agent_host.getWorldState()
]]></programlisting> 
    </section>  
     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
</chapter>    
